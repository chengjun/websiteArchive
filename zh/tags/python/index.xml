<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on </title>
    <link>https://chengjun.github.io/zh/tags/python/index.xml</link>
    <description>Recent content in Python on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2016 Cheng-Jun Wang</copyright>
    <atom:link href="/zh/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NetworkX初步：创建网络、提取属性和绘图</title>
      <link>https://chengjun.github.io/zh/post/cn/2014-08-14-networkx-intro/</link>
      <pubDate>Thu, 14 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/zh/post/cn/2014-08-14-networkx-intro/</guid>
      <description>&lt;p&gt;NetworkX是使用python分析网络数据的重要武器。它的使用非常简单。&lt;/p&gt;

&lt;p&gt;首先，创建网络对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import matplotlib.pyplot as plt
import networkx as nx

G=nx.DiGraph()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，添加链接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;G.add_edge(&#39;source&#39;,1,weight=80)
G.add_edge(1,2,weight=50)
G.add_edge(1,3,weight=30)
G.add_edge(3,2,weight=10)
G.add_edge(2,4,weight=20)
G.add_edge(2,5,weight=30)
G.add_edge(4,5,weight=10)
G.add_edge(5,3,weight=5)
G.add_edge(2,&#39;sink&#39;,weight=10)
G.add_edge(4,&#39;sink&#39;,weight=10)
G.add_edge(3,&#39;sink&#39;,weight=25)
G.add_edge(5,&#39;sink&#39;,weight=35)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以很容易提取边的权重:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;edges,colors = zip(*nx.get_edge_attributes(G,&#39;weight&#39;).items())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算加权过的出度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d = G.out_degree(weight = &#39;weight&#39;) #计算节点的中心度
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择一个常用的可视化方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pos=nx.spring_layout(G) #设置网络的布局
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绘制网络:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nx.draw(G, pos, node_color = &#39;orange&#39;, with_labels = True,
        nodelist = d.keys(), node_size = [v*5 for v in d.values()], 
        edgelist = edges, edge_color = colors, width = 5, edge_cmap=plt.cm.Blues)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://chengjun.qiniudn.com/demo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;计算流距离：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;&#39;&#39;
# get flow distance
&#39;&#39;&#39;
def toSink(G, i):
        try:
            di = G[i][&#39;sink&#39;].values()[0]
        except:
            di = 0 
        return di

def flowDistanceDT(G): #input a balanced nx graph
    R = G.reverse()
    mapping = {&#39;source&#39;:&#39;sink&#39;,&#39;sink&#39;:&#39;source&#39;} 
    H = nx.relabel_nodes(R,mapping)
    #---------initialize flow distance dict------
    L = dict((i,1) for i in G.nodes())  #FlowDistance
    #---------prepare weighted out-degree dict------
    D = {i: toSink(G, i) for i in G.nodes()} #Di
    T = G.out_degree(weight=&#39;weight&#39;)        #Ti
    #---------iterate until converge------------
    ls = np.array(L.values())
    delta = len(L)*0.01 + 1
    while delta &amp;gt; len(L)*0.01:
        for i in L:
            l=1
            for m,n in H.edges(i):
                l+=L[n]*H[m][n].values()[0]/float(T[m])
            L[i]=l
        delta = sum(np.abs(np.array(L.values()) - ls))
        ls = np.array(L.values())
    #---------clean the result-------
    del L[&#39;sink&#39;]
    for i in L:
        L[i]-=1
    L[&#39;sink&#39;] = L.pop(&#39;source&#39;)
    T[&#39;sink&#39;] = T.pop(&#39;source&#39;)
    D[&#39;sink&#39;] = D.pop(&#39;source&#39;)
    return L.values(), D.values(), T.values()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>第4章 派系、聚类和组元</title>
      <link>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter4/</guid>
      <description>&lt;p&gt;在前面章节中，我们主要分析了社会网络中的个体特征。从这一章开始， 我们将开始循序渐进探讨网络中的更大的分析单元，不仅分析个体及其相互联系特征，还要分析所有子图和聚类的特征。我们将探索处于一个三元组当中到底意味着什么，以及作为结构洞的好处和压力。
首先，我们将通过逐步去除部分网络的方法来解构网络，以便找到网络的核心(有时有多个核心)；接着，我们将使用网络的组分（二元组、三元组、派系、家族和聚类）来重构网络。&lt;/p&gt;

&lt;p&gt;##4.1组元和子图
为了将网络分解为可分析的单元，我们将首先给出一些定义：&lt;/p&gt;

&lt;p&gt;•   子图 子图（subgraph）是由一个网络的部分节点及这些节点之间的链接构成。任意一组节点都可以构成子图，稍后我们会介绍一些使用子图的有趣的方法。&lt;/p&gt;

&lt;p&gt;•   组元 组元（components)）是由网络当中相互分隔的部分构成。比如，在罗密欧和朱丽叶相遇之前，他们所在的两个家族没有联系（互相仇视，水火不容），因而可以被看作两个组元。&lt;/p&gt;

&lt;p&gt;许多真实的网络，尤其是那些通过随机抽样搜集到的网络数据，有很多组元存在。有些人可以质疑这是抽样误差（这是很有可能的）造成，但同时，这也可能只是意味着这些组元之间的链接在样本框之外，因此实际上这些组元之间本来就没有关联。&lt;/p&gt;

&lt;p&gt;###使用Python分析组元
埃及暴动的推特转发网络是一个具有很多组元的网络的好例子。本书所讨论的推特转发网络数据，因为只收集了1%的推特用户所发的微博信息，所以很不完整。让我们读入并检查该数据。NetworkX包含一个分析孤立的相互关联的组元的命令（connected_component_subgraphs(e); 这个命令可以根据各个相互关联的组元返回其相应的图对象的数组）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e=net.read_pajek(&amp;quot;egypt_retweets.net&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; len(e)
25178
&amp;gt;&amp;gt;&amp;gt; len(net.connected_component_subgraphs(e))
3122
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上程序表明这个转发网络包含约25000个节点，但这个网络被分割成为超过3000个组元的子图。我们现在可以分析这些组元的规模大小的分布：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import matplotlib.pyplot as plot
&amp;gt;&amp;gt;&amp;gt; x=[len(c) for c in net.connected_component_subgraphs(e)]
&amp;gt;&amp;gt;&amp;gt; plot.hist()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在约3100个组元中，有2471个组元的规模是1——这些节点被称之为“孤立点”，并且应该从网络的剔除。有546个组元的大小是2（也就是只有一个转发），67个组元的规模是3， 14个组元的规模是4，11个组元的规模是5。组元的规模等于或大于10的情况，其频数非常小：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [len(c) for c in net.connected_component_subgraphs(e) if len(c) &amp;gt; 10]
[17762, 64, 16, 16, 14, 13, 11, 11]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码表明存在一个大小超过17000的巨大组元，7个组元的规模小于100，规模介于100到17000之间，不存在任何组元。&lt;/p&gt;

&lt;p&gt;在这个特例中，我们可以将这个巨大组元看作整个网络进行分析；但这个网络仍然因为规模太大而不能得出有趣的推论。&lt;/p&gt;

&lt;p&gt;###网络中的岛屿
一个分析网络的技术被称之为“岛屿方法”（参见图 4-1）；这种方法尤其适合于分析权重网络，比如我们作为例子的埃及革命的推特转发网络。
岛屿方法按照以下过程工作：将我们的网络想象成一个具有复杂地形的岛屿，地形中每一个点的高度被定义为节点的数值（比如程度中心性）或边（比如转发量）。现在环绕这个岛屿的海平面高度随着时间缓慢增加，使得岛屿随着时间逐渐没于水面以下。到岛上的低谷被海水覆盖，这个岛屿就被分割为众多小岛——使得岛屿的最高峰显露出来，并且随着时间增长，这些显露于海面以上的高峰逐渐变小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3799/9457227648_2c4a787869.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-1 岛屿方法&lt;/p&gt;

&lt;p&gt;当海水高度足够高之后，整个岛屿都可能完全消失在海水下面。因为，为了得到有意义的结果，这种方法需要被恰当地使用。&lt;/p&gt;

&lt;p&gt;对于网络而言，使用岛屿方法（ island method ）意味着大的组元将被分割为小的组分，并且具有最多的转发量的区域（子核）成为他们各自可以被单独分析的组元。&lt;/p&gt;

&lt;p&gt;使用岛屿方法时，我们所需要做的第一件事情是建立一个命令来提高“水平面高度”。这个命令使用一个门槛数值（也就是“水平面高度”）对图进行操作，使得权重超过该门槛值的边保存下来，移除掉剩余的其它的边。不用担心，这个命令会保存原来的图，因此它是非破坏性的（即并不损失信息）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def trim_edges(g, weight=1):
    g2=net.Graph()
    for f, to, edata in g.edges(data=True):
        if edata[&#39;weight&#39;] &amp;gt; weight:
            g2.add_edge(f,to,edata)
    return g2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我们开始定义“水平面”如何被提高。我们将要生成一组均匀分布的门槛值作为“水平面”，并依据这些“水平面”生成一组网络：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def island_method(g, iterations=5):
    weights= [edata[&#39;weight&#39;] for f,to,edata in g.edges(data=True)]

    mn=int(min(weights))
    mx=int(max(weights))
    #compute the size of the step, so we get a reasonable step in iterations 
    step=int((mx-mn)/iterations)

    return [[threshold, trim_edges(g, threshold)] for threshold in range(mn,mx,step)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上程序中的函数将返回一组图对象，每一个图对应着一个特定的“水平面”。
现在我们针对埃及革命的推特转发网络中的最大的组元进行分析，先使用岛屿方法将其分割为子部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cc=net.connected_component_subgraphs(e)[0]
&amp;gt;&amp;gt;&amp;gt; islands=island_method(cc)
&amp;gt;&amp;gt;&amp;gt; for i in islands:
... # 输出水平面高度、图大小、连接的组件的数量
... print i[0], len(i[1]), len(net.connected_component_subgraphs(i[1]))

        1 12360 314 
        62 27 11 
        123 8 3
        184 5 2
        245 5 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上程序是什么意思？当门槛值取值为1时，所有取值为1的网络链接（即一步转发的推特）被剥离，这个最大的组元被分割为314个“岛”的子图——每一个代表一组持续地相互转发的人群。因为一次转发可以被认为偶然的，所以这是一个很有用的结果——持续的转发，更常见于那些经常交流并因此培养出某种信任关系的群体当中。&lt;/p&gt;

&lt;p&gt;门槛值取值为62（即每对节点之间的最小转发为62）时，只有27个节点保留下来，分布于11个“岛屿”之中。在这个例子当中，62是最有意义的门槛值——剩下的27个节点是最积极地卷入解放广场示威的人和报道这个事件的记者。&lt;/p&gt;

&lt;p&gt;这可能需要经过一个试错的过程，但一个设置合理的“水平面”可以针对大的网络生成一个非常有意义的结果——立刻找到网络中最活跃的核心节点。&lt;/p&gt;

&lt;p&gt;##4.2子图——自我中心网&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自我中心网&lt;/strong&gt;（Ego networks）是一个以某一特定节点为核心的子网络。在脸书和LinkedIn上面，自我中心网通常被描述为“你的网络”——但是你只能看到你自己的自我中心网，而不能做一个覆盖范围更为广阔的调查。拥有一个大的数据可以使得我们测量和比较不同人的自我中心网。
我们通过运行一个广度优先搜索（参见本书第2章：广度优先搜索）并且限制搜索的深度（网络半径）为一个通常不超过3的数值的方式，来获得自我中心网。不同的是，在通常的广度优先搜索当中，我们通过构建一个链接树的方式找到要搜索的节点，而为了生成一个自我中心网，我们需要获取特定的中心节点的所有邻居之间的所有链接。&lt;/p&gt;

&lt;p&gt;为了理解采用一个小的搜索深度的方法获取自我中心网背后的逻辑，我们需要重温在网络中与其它节点连接意味着什么，以及网络距离的意义是什么。通常情况下，网络链接的一个例子是“爱丽丝是鲍勃的朋友”，一个数值为2的网络距离的一个例子则是“卡洛尔是爱丽丝的一个朋友的朋友”，而一个数值为3的网络距离的例子是“戴夫是爱丽丝的一个朋友的朋友的朋友”。直觉上讲，我们将其理解为虽然我们对我们的朋友了解很多，我们对我们的一些朋友的朋友的情况也略有所知，但我们几乎不知道任何我们朋友的朋友的朋友的事情。&lt;/p&gt;

&lt;p&gt;严格地说，网络距离这个概念被表达为“可观测性的界限” （Horizon of Observability），是一个从物理学和“可观测的宇宙”这个提法当中灵活借鉴而来的概念。诺亚•弗里德（Noah Friedkin）发现在社会网络中，人们对于自己所在的自我中心网非常了解（错误率约为30%），其所报告数据质量与通过自我报告的方式收集的数据质量一样好。二度网络距离的错误率跃为70%，三度网络距离的错误率则高达100%。&lt;/p&gt;

&lt;p&gt;在诸如推特这种在线社会网络，因为对于朋友的定义非常松散以及电脑辅助的信息保存方式，自我中心网的半径要大很多。信任和影响力所流经的人际网络渠道并不太稳固，所以分析一个网络半径大于3的自我中心网的将会是一个错误。当我们研究通过一系列转发的形式而进行的信息扩散时（我们将在第6章介绍），深度优先的搜索方式将替代广度优先的策略而被使用。&lt;/p&gt;

&lt;p&gt;###使用Python提取和可视化自我中心网
提取自我中心网非常简单，因为NetworkX提供一个现成的内置函数来完成这个工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; net.ego_graph(cc,&#39;justinbieber&#39;) 
&amp;lt;networkx.classes.multigraph.MultiGraph object at 0x1ad54090&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，不管信不信，贾斯汀•比伯（Justin Bieber）也在埃及转发网络数据当中。他的自我中心网早已经出现于本书中，见图1-11。
这个ego_graph函数返回一个NetworkX图对象，并且所有的常见的度量（程度中心性，居间中心性等）能够通过它计算。&lt;/p&gt;

&lt;p&gt;但是，一些其它的简单的度量并未被纳入其中。知道一个自我中心网的规模对于理解一个人转发的（或收到的）信息能够传播的范围非常重要。
另外一个度量被称为聚类系数（clustering coefficient）——本质上，它测量了你的朋友彼此之间也是朋友的比例（也就是人们之间的相互信任程度）。这个度量可以被应用于整个网络当中——但是对于一个密度差异很大并且有多个核心的大的网络，平均的聚类系数很难解读。在自我中心网当中，对于聚类系数的解释非常简单——一个自我中心网，稠密且嵌入了很多相互信任的节点，具有一个较高的聚类系数。由一个单一向外“广播”的核心节点和众多“听众”构成的星型网络，则具有一个较低的聚类系数。
让我们开始探索一下埃及数据中的一些自我中心网：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 我们需要将自我中心网从一个多图转化为一个简单的图。 
&amp;gt;&amp;gt;&amp;gt; bieb = net.Graph(net.ego_graph(cc,&#39;justinbieber&#39;, radius=2))
&amp;gt;&amp;gt;&amp;gt; len(bieb)
22
&amp;gt;&amp;gt;&amp;gt; net.average_clustering(bieb) 
0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贾斯汀•比伯(Justin Bieber)的名人地位并未能够在这个特定例子中帮到他——在他的九百万个关注者当中，仅仅有二十二个人转发了他的关于埃及革命的信息。他的聚类系数表明他是一位纯粹的“广播者”，并未被嵌入他的粉丝的信任网络中——或者，至少，他并不在一个关心世界政治的信任网络中。&lt;/p&gt;

&lt;p&gt;让我们现在探索一个不同类型的名人——威尔•戈宁(Wael Ghonim)，新一代的埃及人，Google的主管，推特的重度使用者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ghonim= net.Graph(net.ego_graph(cc,&#39;Ghonim&#39;, radius=2)) 
&amp;gt;&amp;gt;&amp;gt; len(ghonim)
3450
&amp;gt;&amp;gt;&amp;gt; net.average_clustering(ghonim)
0.22613518489812276
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;威尔• 戈宁不仅有一个巨大的转发网络（尽管比贾斯汀•比伯的粉丝少100倍），他的自我中心网是一个人们从他这里以及其他人那里转发信息的信任网络，一个革命的信息可以很容易扩散和持续的网络。
在下一部分我们要讨论的结构洞和三元组分析对于自我中心网同样非常适用——所以敬请期待并且开始分析你自己的数据！
4.3三元组
一个三元组其实就是三个节点以某种形式相互链接。无论如何，在三元组分析中，情况并非如此简单。图4-2列出了所有可能的无向（undirected ）的三元组；正如你所看到的，仅有前两个类型当中的所有节点是相互链接的， 并因此具有独特的意义。有向的三元组共有16种，但我们将在本章稍后的部分讨论。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2865/9457227586_25d19e8e24.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-2 三元组的形式&lt;/p&gt;

&lt;p&gt;图字翻译：&lt;/p&gt;

&lt;p&gt;闭合的三元组（图4-2中左侧）展现的是一个完全连接的群体：A，B，和C以相同强度的边相互连接。闭合的三元组的一个最简单的例子是“核心家庭”——妈妈（爱丽丝），爸爸（鲍勃）和一个孩子（卡洛尔）。当然，这些三元组可以相互重合——例如，同一个妈妈和爸爸可能还有另外一个儿子（大卫），这种情况下三元组不止有一个，而是四个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[爱丽丝，鲍勃，卡洛尔]
[爱丽丝，鲍勃，大卫]
[卡洛尔，大卫，爱丽丝]
[卡洛尔，大卫，鲍勃]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个网络结构或许代表了社会网络研究领域当中最古老的一种研究。在1908年，乔治•齐美尔，一位与马克斯•韦伯同时代的人， 与他的知识分子圈的一位成员一起写作了一篇论文《三元组论》。&lt;/p&gt;

&lt;p&gt;齐美尔认为在一个二元组（dyad ）（也就是两个节点相互连接在一起）中，每个人都能够保持他们的个体性并维持一段亲密关系。二元组有助于信息和意见的交流，但它并未使得个体融入群体。在三元组当中，第三个个体成为一个平衡的本源（提供不同的意见并舒缓精神）。但第三个节点也是一个反馈的渠道——来自A的信息传递到B，然后到C，并以一种非常扭曲的形式回到A——正如一个儿童的游戏“打电话”所表明的一样。&lt;/p&gt;

&lt;p&gt;作为一种不断扭曲的结果，一个三元组随着时间的推移生成一组三元组所特有的人造品——方言土语或绰号昵称，局部的规范和行为准则，共享的意义。在一个宏大的语境里，社会学家把这种人造品的累积称为文化。
或许在一个三元组的语境里，三元组是一个非常大的词语——但可以想象一下你自己的家庭或者你的朋友的家庭。或者，下载一集ABC播出的真人秀《交换女主人》（Wife Swap, 幸运地在2009年取消了），并观看两个家庭文化的在真人秀中的碰撞。&lt;/p&gt;

&lt;p&gt;###大学生联谊会研究——链接的稳定性与三元组&lt;/p&gt;

&lt;p&gt;另外一个相似的研究由纽科姆完成。  实际上，这个研究与现代真人秀电视节目有些（惊人的）相似，但是发生于二十世纪六十年代早期。想象一家位于密歇根的大学生联谊会 （是的，有啤酒 ） 。在学期开始，17个学生（都是白人）被招募住在一个大学生联谊会的房子里长达一个学期时间， 以交换他们的个人信息数据为条件。每周，研究者访问每一个学生成员并让他们对与之互动的成员按照1（最好）到16(最差)的顺序进行排序。&lt;/p&gt;

&lt;p&gt;这个研究发现：&lt;/p&gt;

&lt;p&gt;•   不对称的链接（例如“我喜欢你多过你喜欢我”）最不稳定，维系不超过两周时间。&lt;/p&gt;

&lt;p&gt;•   对称的链接（二元组中的两个人以相同的程度喜欢彼此）明显更稳定。&lt;/p&gt;

&lt;p&gt;•   三元组结构随着时间的推移是最稳定的，三元组中的学生们一起消弭冲突，组织活动，并奠定兄弟会内部相互交往的风气。&lt;/p&gt;

&lt;p&gt;###三元组和恐怖分子&lt;/p&gt;

&lt;p&gt;在本书第1章的“恐怖组织的信息网络”， 我们提到基地组织（Al Qaeda cells）在训练和准备恐怖袭击的时候被隔绝于一个安全的藏身处。这种隔绝迫使组织形成一种稠密的三元组结构，每个人都与其他人一起嵌入在三元组中。加上实际上的感觉剥夺（所有来自外部世界的信息被组织的领导者过滤），这个群体生成他们自己的超越了绰号和共有的故事的文化人造品——继续强化他们作为宗教极端分子的身份并加强他们完成袭击的决心。&lt;/p&gt;

&lt;p&gt;引用马克•萨基曼（Mark Sageman） 的话来说，汉堡支部（谋划并最终参与执行了911恐怖袭击）就是——“一群人”。在分析了17个恐怖分子的生活之后，萨基曼发现驱动他们的最主要因素是他们在恐怖组织内部的社会关系。大多数人开始的时候是朋友，同事，或者亲属——并且关系因为友谊、忠诚、团结和信任的纽带而更亲密，并获得强烈的归属感和集体身份。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2864/9457227588_a0b0c91341_z.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图4-3 911劫机者的社会网络&lt;/p&gt;

&lt;p&gt;在本书的Github库 (&lt;a href=&#34;https://github.com/maksim2042/SNABook/chapter4)当中,你可以找到用来生成图4-3&#34; target=&#34;_blank&#34;&gt;https://github.com/maksim2042/SNABook/chapter4)当中,你可以找到用来生成图4-3&lt;/a&gt; 的数据 ，并且自己分析它。数据以边列表的形式存储于文件当中，其格式如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hani Hanjour,Majed Moqed,5,1
Hani Hanjour,Nawaf Alhazmi,5,1
Hani Hanjour,Khalid Al-Mihdhar,5,1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一列是有向边指出的节点的名字，第二列是有向边指入的节点的名字，并且接下来的两个数字表示边的强度（5=最强的边，1=最弱的边）和边被确认的程度（1=被确认的亲密关联，2=各种被记录的交往活动， 3=潜在的或计划的或未确认的交往活动）。&lt;/p&gt;

&lt;p&gt;导入这个文件时，我们无法使用NetworkX内置的文件读入功能，但我们可以用短短几行代码构建一个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import csv ## 我们将使用内置的 CSV库
import networkx as net
# 打开文件
in_file=csv.reader(open(&#39;9_11_edgelist.txt&#39;,&#39;rb&#39;))
g=net.Graph()
for line in in_file:
    g.add_edge(line[0],line[1],weight=line[2],conf=line[3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有一个标明19个劫机者曾经乘坐过的航班的属性文件。让我们也把这个数据读入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 首先，我们应该确认所有的额节点都具有“flight”属性
for n in g.nodes_iter(): g.node[n][&#39;flight&#39;]=&#39;None&#39;
attrb=csv.reader(open(&#39;9_11_attrib.txt&#39;,&#39;rb&#39;))
for line in attrb:
    g.node[line[0]][&#39;flight&#39;]=line[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tips：
通常有两种方法列出图中的节点。g.nodes()提供了一列节点，而g.nodes_iter()生成一个Python迭代器。迭代器仅限于在循环当中——但仅仅使用很少的内存并且在大图当中运行更快。&lt;/p&gt;

&lt;p&gt;如果你现在使用默认的net.draw(g)函数将这个网络画出来，你会发现这个网络包含了几个互补相连的组元。这是因为这个数据是支离破碎和不完整的；我们仅仅关注网络中的最大组元：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Connected_component_subgraphs()返回一系列的组元，
# 按照从最大到最小的顺序排列
components=net.connected_component_subgraphs(g)

# 找出第一个也是最大的组元
cc = components[0]
我们使用multimode.py中的一个惯用的绘图函数来绘制这张图片。这个函数读入节点属性，并根据节点属性的取值分配颜色，迅速地绘制一个惯用的彩色图片：
import networkx as net
import matplotlib.pyplot as plot
from collections import defaultdict
def plot_multimode(m,layout=net.spring_layout,
type_string=&#39;type&#39;,filename_prefix=&#39;&#39;,output_type=&#39;pdf&#39;):
    ## 创造一个默认的颜色序列和一个空的彩色图
    colors=[&#39;r&#39;,&#39;g&#39;,&#39;b&#39;,&#39;c&#39;,&#39;m&#39;,&#39;y&#39;,&#39;k&#39;]
    colormap={}
    d=net.degree(m) #we use degree for sizing nodes
    pos=layout(m) #compute layout
    # 现在我们需要找出需要绘制不同颜色的节点构成的群体
    nodesets=defaultdict(list)
    for n in m.nodes():
        t=m.node[n][type_string]
        nodesets[t].append(n)
    ## 使用相应的颜色设置，将每组中的节点分开绘制
    print &amp;quot;drawing nodes...&amp;quot;
    i=0
    for key in nodesets.keys():
        ns=[d[n]*100 for n in nodesets[key]]
        net.draw_networkx_nodes(m,pos,nodelist=nodesets[key], node_size=ns,
        node_color=colors[i], alpha=0.6)
        colormap[key]=colors[i]
        i+=1
        if i==len(colors):
            i=0  ### 如果我们用光了所有的颜色，那么循环使用这些颜色
    print colormap
    ## 使用一个默认的绘图机制绘制边
    print &amp;quot;drawing edges...&amp;quot;
    net.draw_networkx_edges(m,pos,width=0.5,alpha=0.5)
    net.draw_networkx_labels(m,pos,font_size=8)
    plot.axis(&#39;off&#39;)
    if filename_prefix is not &#39;&#39;:
        plot.savefig(filename_prefix+&#39;.&#39;+output_type)
最后，我们绘制出网络：
import multimode as mm

# type-string 指引函数某种需要辨别的属性
mm.plot_multimode(cc,type_string=&#39;flight&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们建立了用于三元组分析的工具，你可以使用这个数据作为一个理解三元组如何工作的测试，并与关于恐怖主义研究的大量文献潜在地联系起来。&lt;/p&gt;

&lt;p&gt;###“禁止进入的三元组”和结构洞&lt;/p&gt;

&lt;p&gt;我的朋友鲍勃  有一个问题。你明白的，他爱上了两个女人。一个是精力充沛的东欧美女（让我们称她为爱丽丝），另一个是来自南美洲的乐天派女孩卡若琳娜。这两位女孩中的任何一个对于鲍勃来说都是绝配，但是他无法决定。当鲍勃和爱丽丝在一块的时候，他渴望见到卡洛琳娜和她无忧无虑的态度；但他和卡洛琳娜在一起的时候，他思念爱丽丝和她美丽以及有深度的谈吐。结果，几年过去了，鲍勃依然处于病态的单身状态中。
从网络角度而言，鲍勃的窘况在于他处于图4-2的第二个三元组中。B与A和C相连——但A与C之间并没有任何连接，并且鲍勃作为图中的B应该维持这种状况如果他想继续同爱丽丝和卡洛琳娜两个人同时交往。每天，鲍勃需要调整他的日程表以确保A和C不会相见，这给鲍勃的生活带来越来越多的压力，但他同样需要确保他不会因为忘记他告诉A或C的事情或者A或者C偶尔告诉他的事情而露馅。结果，鲍勃身处焦虑之中，然而所有的事情并没有按照鲍勃所希望的那样发展。&lt;/p&gt;

&lt;p&gt;我另外一个银行家朋友（Banker）身处与之相似的网络链接当中，但却对此非常高兴。他的A是AmeriCorp公司，而C是CorpAmerica公司。AmeriCorp公司在他的银行里存款并期望5%的利率。而CorpAmerica公司则按照7%的利率从他的银行借款。这样我这个银行家朋友B就获得其中的利率差——C支付的利率和A期望得到的利率之间的2%的差别。对我这个朋友而言，这2%的利率差足够他购买一个房子、一个最新款的宝马车、一个精英俱乐部的成员资格和其它的他非常喜欢的物质财富。假设A和C因为打高尔夫球而认识，他们就会同意A以6%的利率直接借款给C，并意识到撇开中间人对他们双方都有利。如果这件事情发生了，银行家B就会非常沮丧。
尽管在三元组背后的故事完全不同，鲍勃和银行家朋友的意愿却完全相同。他们都需要确保他们的开放的三元组的末端不能直接联系——也就是说A和C之间不会建立网络链接。&lt;/p&gt;

&lt;p&gt;不同的人给这个三元组所取的名字不同。一些研究者称它为“禁止进入的三元组”——因为像鲍勃一样，他们认为这个三元组与压力、焦虑和同时与两个女人约会所带来的道德问题相互关联。其他人称它为“结构洞”或者“中间人结构”，并且认为一个个体所占据的结构洞的数量与其作为企业、银行、经纪人或地产代理的业绩相互关联。&lt;/p&gt;

&lt;p&gt;罗纳德•伯特（Ronald Burst）  的研究表明在一个竞争性的市场当中，占据更多结构洞的商人具有更显著的高成功率。商人的成功是是通过两件事情来预测的——商人在不对称信息的条件下的开拓能力和交易能力，和商人对于创造和维持“套利机遇”过程中多带来的压力的高度容忍度。&lt;/p&gt;

&lt;p&gt;###结构洞和边界跨越
结构洞具有另一个重要的使命——因为他们能够降低信息不对称性（例如，因为我的两个朋友都能够提供信息），他们也能够连接不同的社群。本书的两位作者即是社会网络研究领域的专业人士（马克斯教社会网络分析的课，艾利克斯编写社会网络分析的软件），又是专业的音乐家。事实上，我们两个是在一个摇滚音乐节上相遇的，那时我们两个各自的乐队正在那里表演。&lt;/p&gt;

&lt;p&gt;所以，一个包括马克斯、马克斯在学术研究方面最亲密的合作者和他乐队中的鼓手的三元组实际上是一个结构洞。这些科学家和鼓手对于英语有基本的了解（不存在语言障碍），但找不到足够的谈论的话题。因为社会距离（social distance）（我们将在第6章讨论信息扩散的时候进一步涉及的一个术语）的原因，在他们之间存在网络链接的可能性基本为零。
我们的社群（科学家和音乐家）经常交叉。马克斯之前所在的一个乐队是全部由教授构成的，之后所在的一个摇滚乐队全部由神经科学家构成（称为“Amygdaloids” ），乐队也因此而知名。&lt;/p&gt;

&lt;p&gt;但是，与那些仅仅是专业的音乐家或者科学家的人的规模相比，这些跨界者（懂科学的音乐家和懂音乐的科学家）很少。结果，这两个社群的交叉看上去像图4-4。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2813/9454445729_60156911af.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图4-4 跨界者示意图&lt;/p&gt;

&lt;p&gt;事实上，这种事情在不同层面存在着。如果我们仔细考察科学家群体，我们发现它包含了各个主要的领域（生物学、计算机科学、人类学等），并且如果我们更仔细地看这些领域所包含的子领域，我们会发现它们都通过结构洞联系在一起。&lt;/p&gt;

&lt;p&gt;在科学社群中，这非常重要。因为许多新的发现本质上都是跨学科的。例如，詹姆斯•富勒（James Fowler）  致力于神经科学与社会网络分析交叉领域的研究。&lt;/p&gt;

&lt;p&gt;一些其他的领域（例如经济学）不鼓励跨越不同子领域的对话和论文发表，并对他们的理论过度保护。在这种情况下，比如存在于奥地利学派和新古典经济学之间的结构洞位置将会充满压力并很难维持——这更像鲍勃的困境而非银行家的顺境。&lt;/p&gt;

&lt;p&gt;###政治中的三元组&lt;/p&gt;

&lt;p&gt;图4-5展现了一个不同国家在高加索（ Caucasus）的政治合作网络 。  从现代地缘政治的角度讲，高加索是一个非常有趣的地方（看图4-6中的地图）。这是一个很小的地方，具有异常美丽的山地地貌，它夹在北面的俄罗斯 （Russia）和南面的土耳其（Turkey）和伊朗（Iran ）之间。其居民主要是基督徒和穆斯林民族的混乱得混合，并且他们开始逐渐拥护西方的国家。俄罗斯，或者土耳其（从苏联解体开始）在这里创造了一种令人诧异的地缘政治景观（大多数是令人不高兴的，至少对于当地人来说）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2893/9457227528_52e7e3a37f.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-5 在高加索的政治合作网络&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm6.staticflickr.com/5328/9457227532_d7b2091b39.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-6 高加索—一个种族和语言的熔炉&lt;/p&gt;

&lt;p&gt;图中的网络通过其它国家和高加索、俄罗斯、土耳其、欧盟和美国之间签订的政治合作协议和声明关系而构建，明显表明俄罗斯与其它西方国家之间的政治治理风格的差异。俄罗斯为中心的一方的网络充满了结构洞，俄罗斯实际上控制着这个网络，而边缘国家节点之间的网络链接几乎不存在。&lt;/p&gt;

&lt;p&gt;唯一横向的网络链接存在于南奥塞梯（South Ossetia）和阿布哈兹(Abkhazia)之间。在本研究进行的时候，这两个地方都还是格鲁吉亚的一部分——但实际上，它们当时明显不忠于格鲁吉亚。南奥塞梯的分裂运动（或者，这是一个俄罗斯人为了巩固在该地区的影响而进行的挑拨，这取决于读者的新闻来源是俄罗斯媒体还是美国媒体）在两年内遭到了格鲁吉亚军队一个短暂而血腥的镇压。之后，南奥塞梯和阿布哈兹这两个地方都宣布独立并正式与俄罗斯建立盟友关系。&lt;/p&gt;

&lt;p&gt;同时，西方国家一方的网络表现出一种具有较多亲密关系和横向连接的特征。这将减弱超级大国的影响力，因为横向的网络链接降低了（超级国家）的效率和直接影响。同时，这种三元组结构更加稳定并且不需要很多的力量去维持。&lt;/p&gt;

&lt;p&gt;###有向的三元组
理论足够了，让我们开始编写一些代码！&lt;/p&gt;

&lt;p&gt;图4-7给出了所有的可能的有向的三元组。在一个有向的三元组当中，我们同时考虑单向的边和双向的边；因此总共有16种可能的情况，而非4种情况。我们将对这些形状进行一些解读，但首先让我们定义一种对其进行分类的方法。这种计数和分类的方法或许有一些晦涩难懂，但自从1972年开始，它就成为了这个领域的学术文献中的一种标准 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3750/9454445677_5e5a60f507.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图4-7 有向网络中所有可能存在的三元组&lt;/p&gt;

&lt;p&gt;这些三元组按照1到16 的顺序进行编号，每一个都有一个代码。这些代码按照如下方式进行阅读：&lt;/p&gt;

&lt;p&gt;•   第一个数字代表了双向链接的总数量。&lt;/p&gt;

&lt;p&gt;•   第二个数字代表了单向链接的总数量。&lt;/p&gt;

&lt;p&gt;•   第三个数字代表了不存在的网络链接的总数量。&lt;/p&gt;

&lt;p&gt;•   字母用来区分相同三元组的不同形式——U代表了“向上”，D代表了“向下”，C代表了“传递”（也就是说有两条路径指向相同的节点）&lt;/p&gt;

&lt;p&gt;图中的三元组1到3是未连在一起的，三元组4到8和11代表结构洞的不同形式。三元组9、10和12到16是紧密型三元组的不同形式。&lt;/p&gt;

&lt;p&gt;###分析真实网络中的三元组&lt;/p&gt;

&lt;p&gt;对于一个真实网络的三元组分析的过程成为“三元组普查（triad census）”。在这个过程当中，对于每一个节点，我们计算16种类型三元组出现的频数以决定这个节点在网络中的角色。例如，一个节点具有较多的三元组4、7和11（也就是说有较多的流出的网络链接和结构洞）是一个信息的来源或者潜在的小组领导者。&lt;/p&gt;

&lt;p&gt;执行三元组普查，我们需要一种仍未被纳入NetworkX的一种算法——三元组普查算法 。从Github下载第4章所要用的算法包 ，修改系统目录为下载文件所在的路径，并开启Python：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import networkx as net
&amp;gt;&amp;gt;&amp;gt; import tradic
&amp;gt;&amp;gt;&amp;gt; import draw_triads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个draw_triads函数可以重新绘制出图4-7.&lt;/p&gt;

&lt;p&gt;现在，让我们应用三元组普查到一些抽样数据当中去（比如图4-8当中的风筝网络）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 生成一个有向的风筝网络
&amp;gt;&amp;gt;&amp;gt; g=net.DiGraph(net.krackhardt_kite_graph())
## 执行三元组普查程序
&amp;gt;&amp;gt;&amp;gt; census, node_census = triadic.triadic_census(g)
&amp;gt;&amp;gt;&amp;gt; census
{&#39;201&#39;: 24, &#39;021C&#39;: 0, &#39;021D&#39;: 0, &#39;210&#39;: 0,
&#39;120U&#39;: 0, &#39;030C&#39;: 0, &#39;003&#39;: 22, &#39;300&#39;: 11,
&#39;012&#39;: 0, &#39;021U&#39;: 0, &#39;120D&#39;: 0, &#39;102&#39;: 63,
&#39;111U&#39;: 0, &#39;030T&#39;: 0, &#39;120C&#39;: 0, &#39;111D&#39;: 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2881/9457227436_bbca40d39d_n.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-8 魁克哈特风筝社会网络&lt;/p&gt;

&lt;p&gt;三元组普查函数返回了两个结果——一个包含了网络的所有结果的Python字典，和一个包含了个体节点的所有结果的字典的字典。&lt;/p&gt;

&lt;p&gt;在风筝图当中，这个程序找到24个结构洞类型三元组（代码为201）和11个紧密型三元组（代码为300）。这意味着在网络中存在着一些联系特别紧密的区域和一些充满很多结构洞的区域。当然这个发现对于这个图来说是显而易见得到——但对于一些大的网络来说就不是如此明显。&lt;/p&gt;

&lt;p&gt;结构洞型三元组和紧密型三元组的比例也是非常重要的——一个等级制度主要是由结构洞构成的，而平等主义的网络结构中紧密型三元组具有较高的比例。&lt;/p&gt;

&lt;p&gt;简而言之，一个三元组普查使得我们可以对一个网络结构的宏观层面做出一种高级的结论。但是，这在微观水平上同样有趣。下面的代码生成一个三元组普查表格，其结果在表4-1中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keys=node_census.values()[1].keys()
## 生成一个表格的标题  
print &#39;| Node |&#39;, &#39; | &#39;.join(keys)
## 生成表格的内容
## 需要一点小技巧区将整数转为字符 
for k in node_census.keys():
print &#39;|&#39;, k, &#39;|&#39;,&#39; | &#39;.join([str(v) for v in node_census[k].values()])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;节点  201 021C 021D   210 120U    030C    003 300 012 021U    120D    102 111U    030T    120C    111D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0   8   0   0   0   0   0   0   4   0   0   0   14  0   0   0   0
1   4   0   0   0   0   0   0   3   0   0   0   11  0   0   0   0
2   4   0   0   0   0   0   0   1   0   0   0   7   0   0   0   0
3   3   0   0   0   0   0   0   2   0   0   0   7   0   0   0   0
4   2   0   0   0   0   0   0   0   0   0   0   4   0   0   0   0
5   1   0   0   0   0   0   0   1   0   0   0   5   0   0   0   0
6   1   0   0   0   0   0   0   0   0   0   0   3   0   0   0   0
7   1   0   0   0   0   0   0   0   0   0   0   5   0   0   0   0
8   0   0   0   0   0   0   0   0   0   0   0   7   0   0   0   0
9   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表4-1 风筝网络内部的三元组普查&lt;/p&gt;

&lt;p&gt;现在让我看一下主要的三元组类型:紧密型三元组（代码为300）和结构洞型三元组（代码为201）。&lt;/p&gt;

&lt;p&gt;###真实数据&lt;/p&gt;

&lt;p&gt;让我们现在对在本章前面部分用到的9/11劫机数据执行一次三元组普查，并找出谁拥有最多的派系（紧密型三元组，代码为300）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;census, node_census = triadic.triadic_census(cc)

## 仅仅得到紧密型三元组的数量，并按照其数值进行降序排列
closed_triads=[[-k,v] for k,v in sorted([[-node_census[k][&#39;300&#39;],k] for k in node_census.keys()])]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表中排名最高的人有一个我们很熟悉的姓氏：穆罕默德•阿塔（Mohammed Atta）是最初策划911袭击的汉堡支部的一份子，并且是美国航空公司的第11次航班劫机后的飞行员，他驾驶着飞机撞在了世贸中心的北楼上。&lt;/p&gt;

&lt;p&gt;##4.4派系
虽然我们或许可以直觉地将社会网络中的派系理解为彼此紧密相连的、有黏着力的一群人，在社会网络分析领域对已派系有一个正式的、更为严格的数学定义。&lt;/p&gt;

&lt;p&gt;对于一个给定的图来说，一个派系被定义为其中的一个最大的完全子图（ maximal complete subgraph ）——也就是说，群体中的每个个体都与其他的每一个人相连。“最大”意味着这个派系无法再增加节点，因为如果将其它节点也算入派系，将降低派系内部连通的紧密程度。从本质上讲，一个派系包含着几个相互重叠的紧密型三元组，并且继承着紧密型三元组的许多文化生成功能和放大特征。&lt;/p&gt;

&lt;p&gt;一个派系必须生成共识，否则就会解体——这是为什么在方言里，派系经常被认为与其他派系存在冲突。其实派系与冲突的关系非常容易理解：拥有一个共同的敌人（或者一组共同的敌人）使得派系内部更加团结。我们将在第6章讨论一些关于冲突和派系的含义。但是现在，让我们看一下是否可以在一些样本网络中找到派系。&lt;/p&gt;

&lt;p&gt;###检测派系
作为测试，让我们再看一下高加索地缘政治的数据。这一次，我们将要探索不同国家之间的经济关系（图4-9）。在这个数据当中，经济合作水平的取值范围为0到1之间——1表示一个紧密的或者说独占的网络链接，0表示完全没有经济合作关系：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; eco=net.read_pajek(&amp;quot;economic.net&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; net.draw(eco)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7335/9457227442_438f567e5c_c.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-9 高加索地区的经济联盟与联合行动&lt;/p&gt;

&lt;p&gt;这个数据清晰地表明在这个地区存在着两个不同的力量——以西方国家为中心的一方和以俄罗斯为中心的一方；当地和地方性的经济联系经常是不存在的，作为最近的地理上的邻居（例如亚美尼亚（Armenia）和阿塞拜疆（Azerbaijan）），往往将彼此看作敌人并按此选择与不同的超级大国建立关系。伊朗和土耳其扮演着“捣乱分子”的角色——一个与伊朗有较多经济联系的国家不会和美国有联系，并因此被迫与俄罗斯结盟。当然，石油和天然气也起着非常重要的作用。
一个像这样的结构容易孕育派系。我们看一下是否能够从其中找到派系。首先，我们要丢掉低水平的联系（边的权重 &amp;lt; 0.5）以凸显网络的核心：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e2=trim_edges(eco, weight=0.5)
&amp;gt;&amp;gt;&amp;gt; cliques = list(net.find_cliques(eco))
&amp;gt;&amp;gt;&amp;gt; cliques
[[&#39;EU&#39;, &#39;Turkey&#39;, &#39;Russia&#39;],
[&#39;EU&#39;, &#39;Turkey&#39;, &#39;USA&#39;],
[&#39;EU&#39;, &#39;Azerbajan&#39;],
[&#39;EU&#39;, &#39;Georgia&#39;],
[&#39;EU&#39;, &#39;Kazakhstan&#39;, &#39;Russia&#39;],
[&#39;EU&#39;, &#39;Kazakhstan&#39;, &#39;USA&#39;], [&#39;EU&#39;, &#39;Armenia&#39;],
[&#39;South Osetia&#39;, &#39;Russia&#39;],
[&#39;Nagorni Karabakh&#39;, &#39;Armenia&#39;],
[&#39;Chechnya&#39;, &#39;Russia&#39;],
[&#39;Abkhazia&#39;, &#39;Russia&#39;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们大略地看一下派系的结果：&lt;/p&gt;

&lt;p&gt;•   [EU, Turkey, Russia], [EU, Turkey, USA]–    代表着（两个）超级大国和对于土耳其是否应该成为欧盟成员的论辩的双方。&lt;/p&gt;

&lt;p&gt;•   [EU, Azerbaijan], [EU, Georgia]–    在高加索地区与西方结盟的国家；阿塞拜疆（Azerbaijan）是主要的石油生产国，并且一个英国石油公司所拥有的石油管道穿过阿塞拜疆从格鲁吉亚到达黑海。&lt;/p&gt;

&lt;p&gt;•   [South Ossetia, Russia], [Nagorni Karabakh, Armenia], [Chechnya, Russia], [Abkhazia, Russia]–   所有的最近的冲突 起源于当地的小的共和政体从拥护西方转而拥护俄罗斯（自愿地或者被强迫地）。&lt;/p&gt;

&lt;p&gt;•   [EU, Kazakhstan, Russia], [EU, Kazakhstan, USA]–    哈萨克斯坦是一个主要的天然气生产国，其天然气主要通过俄罗斯拥有的石油管道和液态天然气设施卖给欧盟和美国。&lt;/p&gt;

&lt;p&gt;简而言之，派系算法生成的结果可以很快地被一个熟悉该领域的人解读。&lt;/p&gt;

&lt;p&gt;不幸的是，这些派系之间大多是重叠的，并且一个单一的事件或现象可能导致多个派系。其他的算法（n-clans, k_plexes等）可以帮助解决这个问题——但它们尚未被融入到NetworkX当中，并且它们的应用也超出了本书的范围。&lt;/p&gt;

&lt;p&gt;我们将在下一个部分通过聚类的方法解决这个问题。&lt;/p&gt;

&lt;p&gt;##4.5分层聚类
我们将要接触的（虽然很简略地）另一个类型的算法是聚类算法。聚类算法包罗万象、异常宽广，或许在其它的书籍中被阐述得更好——但我会简单地介绍聚类算法在社会网络分析中的应用，并提供一个从聚类算法中可以得出有用结论的简单例子。&lt;/p&gt;

&lt;p&gt;首先我们回到“距离”的概念。我们可以用很多办法定义距离——从地理距离到在地面上旅行经过的距离，再到以时间计量的距离（例如，从一个地方A到达另一个地方B所要花费的时间），等。在社会网络分析中，我们发现两种距离的概念最为有用：一个是节点之间的图距离（或路径距离）；另一个是以相似度计量的距离（也就是说，如果节点之间在某个方面上相似，我们就认为它们靠得更紧密）。&lt;/p&gt;

&lt;p&gt;在之前的章节中我们使用的高加索网络中，图距离的矩阵如表4-2所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TR  SO  GE  IR  TK  US  AZ  CH  AR  EU  NK  KZ  RU  AB
TR  0   2   1   1   1   1   1   2   1   1   2   1   1   2
SO  2   0   2   2   2   2   2   2   2   2   3   2   1   2
GE  1   2   0   1   1   1   1   2   1   1   2   1   1   2
IR  1   2   1   0   1   2   1   2   1   1   2   1   1   2
TK  1   2   1   1   0   1   1   2   1   1   2   1   1   0
US  1   2   1   2   1   0   1   2   1   1   2   1   1   2
AZ  1   2   1   1   1   1   0   2   2   1   3   1   1   3
CH  2   2   2   2   2   2   2   0   2   2   3   2   1   2
AR  1   2   1   1   1   1   2   2   0   1   1   1   1   2
EU  1   2   1   1   1   1   1   2   1   0   2   1   1   2
NK  2   3   2   2   2   2   3   3   1   2   0   2   2   2
KZ  1   2   1   1   1   1   1   2   1   1   2   0   1   2
RU  1   1   1   1   1   1   1   1   1   1   2   1   0   1
AB  2   2   2   2   0   2   3   2   2   2   2   2   1   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表 4-2 高加索网络中的网络距离&lt;/p&gt;

&lt;p&gt;这当然和地理距离非常不同，并且描绘了在高加索区域中国家之间的合作和拥护关系是交织在一起的，每个个体不是被其本地的联盟国家所环绕，而是被潜在的对手所环绕。&lt;/p&gt;

&lt;p&gt;让我们看一下是否可以在经济网络中找到这些相互敌对的群集（cluster，或译作“簇”）。我们将会使用SciPy包中一个的分层聚类方法和一小段由德鲁•康威（Drew Conway）  原创、在本书中被大幅改进的代码。&lt;/p&gt;

&lt;p&gt;###算法
图4-10展现了（以一种程式化的方式）分层聚类的算法。算法大致按照以下步骤运行：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从最低层开始，每一个节点被分配为一个只包含自己的群集。&lt;/li&gt;
&lt;li&gt;使用距离表（表4-2）找到距离最近的一对节点并将它们合并为一个群集。&lt;/li&gt;
&lt;li&gt;重新就算距离表，把刚刚合并的群集看作一个新的节点。&lt;/li&gt;
&lt;li&gt;重复步骤2和3，直到所有的网络中的节点都已经被合并到一个大得多的群集中（示意图中的最高层）&lt;/li&gt;
&lt;li&gt;选择介于最高层和最底层之间的一个有用的聚类门槛——这需要人工干预而无法机器自动完成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3808/9457227414_bb8889b4c4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-10 分层聚类&lt;/p&gt;

&lt;p&gt;步骤3值得更多的思考。如何计算一个群集和一个节点之间的距离？如何计算两个群集之间的距离？有三个方法可以做这件事情：&lt;/p&gt;

&lt;p&gt;•   单个链接：按照最小的最低配对距离（minimum pairwise distance）合并两个群集。&lt;/p&gt;

&lt;p&gt;•   平均链接：按照最小的平均配对距离（average pairwise distance）合并两个群集。&lt;/p&gt;

&lt;p&gt;•   最大链接或完全链接： 按照最小的最高配对距离（maximum pairwise distance）合并两个群集。&lt;/p&gt;

&lt;p&gt;完全链接方法被认为对异常值非常敏感；单个链接方法容易形成链状的、一长串的群集，这与我们关于群集的意义的直觉理解不同；平均链接方法是其它两种方法的折中，也是最常用的方法。&lt;/p&gt;

&lt;p&gt;###城市聚类
为了更好地展现聚类是如何实现的，让我们来思考一个美国本土城市的聚类问题。初始的距离表如下所示；我们将使用单个链接的聚类方法：&lt;/p&gt;

&lt;p&gt;【此处 插入p83表格】&lt;/p&gt;

&lt;p&gt;在前两步当中，我们要合并波斯顿、纽约和华盛顿为一个群集。我们将会发现东海岸城市被合并为一个它们自己的群集：&lt;/p&gt;

&lt;p&gt;【此处插入p84表格1】&lt;/p&gt;

&lt;p&gt;跳过一些步骤，芝加哥进入东海岸城市群集，而旧金山和西雅图构成了西海岸城市群集。严格的说，芝加哥和丹佛应该形成一个中西部城市群集——但因为我们使用了单个链接距离量度，芝加哥结果与东海岸城市群集的距离比与丹佛的距离更近。&lt;/p&gt;

&lt;p&gt;【此处插入p84表格2】&lt;/p&gt;

&lt;p&gt;此时，仅仅剩下迈阿密和丹佛的群集仍未分配。在接下来的几步当中，丹佛加入芝加哥所在的东海岸城市群集。此时，我认为进一步的聚类不再有任何意义。&lt;/p&gt;

&lt;p&gt;长距离的链条（从东海岸城市群集到芝加哥，再到丹佛，最后到达西海岸城市群集）是单个距离量度方法的一个众所周知的不足之处。如果我们此时使用平均链接方法，聚类的结果将会更为清晰。获得更为清晰结果的代价是较高的计算复杂性——这使得平均链接聚类方法不适用于非常大的数据。&lt;/p&gt;

&lt;p&gt;###准备数据和聚类
让我们现在开始在高加索网络数据中应用分层聚类的方法。首先，需要计算距离矩阵。NetworkX提供了一个函数可以生成这样的一个矩阵——但返回的结果是一个嵌入字典的字典（dict of dicts）。这种返回数据的格式不适于做进一步的运算，并且需要被转换到SciPy的矩阵中来。因为矩阵形式的数据不会保留节点的标签，我们构建了另外一个数组来保存这些节点的标签。&lt;/p&gt;

&lt;p&gt;最后，我们执行SciPy的分层聚类算法并得到所有聚类结果的树形图，这个树形图与图4-10类似。我们需要确定一个门槛值——此处，我们任意挑选一个数值，但是因为它是一个参数，所以很容易被改进以得到更有意义的结果。&lt;/p&gt;

&lt;p&gt;例4-1 分层聚类算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__author__ = &amp;quot;&amp;quot;&amp;quot;\n&amp;quot;&amp;quot;&amp;quot;.join([&#39;Maksim Tsvetovat &amp;lt;maksim@tsvetovat.org&#39;,
                  &#39;Drew Conway &amp;lt;drew.conway@nyu.edu&amp;gt;&#39;,
                             &#39;Aric Hagberg &amp;lt;hagberg@lanl.gov&amp;gt;&#39;])
from collections import defaultdict
import networkx as nx
import numpy
from scipy.cluster import hierarchy
from scipy.spatial import distance
import matplotlib.pyplot as plt
def create_hc(G, t=1.0):
    &amp;quot;&amp;quot;&amp;quot;
    从距离矩阵中创造一个图G的分层聚类
    马克西姆注：对带有标签的图进行聚类的前处理和后处理，并返回聚类的结果
    参数化门槛值之后，其取值范围应该通过对每个数据进行尝试的基础上确定
    &amp;quot;&amp;quot;&amp;quot;
    &amp;quot;&amp;quot;&amp;quot;在对德鲁•康威（Drew Conway）编写的代码进行优化的基础上而来&amp;quot;&amp;quot;&amp;quot;
    ## 创造最短路径距离矩阵，但是保留节点标签
    labels=G.nodes()
    path_length=nx.all_pairs_shortest_path_length(G)
    distances=numpy.zeros((len(G),len(G)))
    i=0
    for u,p in path_length.items():
        j=0
        for v,d in p.items():
            distances[i][j]=d
            distances[j][i]=d
            if i==j: distances[i][j]=0
            j+=1
        i+=1
    # 创造分层聚类
    Y=distance.squareform(distances)
    Z=hierarchy.complete(Y) # Creates HC using farthest point linkage
    # 这种划分的选择是任意的，仅仅为了说明 的目的
                          membership=list(hierarchy.fcluster(Z,t=t))
    # 为块模型（blockmodel）创造一系列的列表
    partition=defaultdict(list)
    for n,p in zip(list(range(len(G))),membership):
    partition[p].append(labels[n])
    return list(partition.values())
    # Create collection of lists for blockmodel
    partition=defaultdict(list)
    for n,p in zip(list(range(len(G))),membership):
        partition[p].append(labels[n])
    return list(partition.values())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上述分层聚类算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import hc
&amp;gt;&amp;gt;&amp;gt; hc.create_hc(eco)
[[&#39;Turkmenistan&#39;, &#39;Nagorni Karabakh&#39;, &#39;Russia&#39;, &#39;Abkhazia&#39;],
[&#39;USA&#39;, &#39;Armenia&#39;, &#39;EU&#39;, &#39;Kazakhstan&#39;],
[&#39;Turkey&#39;, &#39;Georgia&#39;, &#39;Iran&#39;, &#39;Azerbaijan&#39;],
[&#39;Chechnya&#39;], [&#39;South Osetia&#39;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结果从直觉上来说非常容易理解——[[&amp;lsquo;Turkmenistan&amp;rsquo;, &amp;lsquo;Nagorni Karabakh&amp;rsquo;, &amp;lsquo;Russia&amp;rsquo;, &amp;lsquo;Abkhazia&amp;rsquo;]是一个以俄罗斯为中心的群集；而[&amp;lsquo;USA&amp;rsquo;, &amp;lsquo;Armenia&amp;rsquo;, &amp;lsquo;EU&amp;rsquo;, &amp;lsquo;Kazakhstan&amp;rsquo;]这个群集主要是跟天然气买卖和运输有关系的；[&amp;lsquo;Turkey&amp;rsquo;, &amp;lsquo;Georgia&amp;rsquo;, &amp;lsquo;Iran&amp;rsquo;, &amp;lsquo;Azerbaijan&amp;rsquo;]这个群集代表的是支持伊斯兰和波斯的态度。对格鲁吉亚（Georgia）的聚类有一些不合适，因为它在政治上是与天主教和西方国家结盟的，但它在经济上与阿塞拜疆和土耳其联系紧密，因而抵消了它亲西方的面貌。剩下的聚类结果则充满了异常值 ——实际上，这些小国家也给这个世界带来了不少麻烦。&lt;/p&gt;

&lt;p&gt;###块模型
一个块模型（block model）是一个从原始网络中提取出来的简化的网络，其中处于同一个群集中的节点被看作是一个节点，而所有的原始的节点之间的关系也被累加为块之间的关系。
在我们作为例子的数据当中，一个块模型所展现的是俄罗斯为中心的群集（0）、西方为中心的群集（1）和伊斯兰为中心的群集(2)之间的关系。而群集3和4主要是一些小的、与俄罗斯联系紧密的、但彼此之间几乎不存在任何联系的共和国——因为俄罗斯对于周边的附属国家的管理是高度中心化的。&lt;/p&gt;

&lt;p&gt;计算块模型，首先需要计算并保存分层聚类的结果，然后需要将群集划分的结果存储为一个列表并在此基础上对原始的图运行块模型。结果如图4-11所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; clusters=hc.create_hc(eco)
&amp;gt;&amp;gt;&amp;gt; M=nx.blockmodel(eco,clusters)
&amp;gt;&amp;gt;&amp;gt; net.draw(M)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3797/9457227386_6d225080a1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图4-11 高加索网络的块模型&lt;/p&gt;

&lt;p&gt;hiclus_blockmodel.py提供了一个可以被应用到所有图的一个更精细的绘图方法：&lt;/p&gt;

&lt;p&gt;例4-2 同时绘制一个网络图及其块模型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    __author__ = &amp;quot;&amp;quot;&amp;quot;\n&amp;quot;&amp;quot;&amp;quot;.join([&#39;Maksim Tsvetovat &amp;lt;maksim@tsvetovat.org&#39;,
      &#39;Drew Conway &amp;lt;drew.conway@nyu.edu&amp;gt;&#39;,
                      &#39;Aric Hagberg &amp;lt;hagberg@lanl.gov&amp;gt;&#39;])

    from collections import defaultdict
    import networkx as nx
    import numpy
    from scipy.cluster import hierarchy
    from scipy.spatial import distance
    import matplotlib.pyplot as plt
    import hc

    &amp;quot;&amp;quot;&amp;quot;在原始网络旁边绘制一个块模型&amp;quot;&amp;quot;&amp;quot;

    def hiclus_blockmodel(G):
        # 提取最大的联通组元
        H=nx.connected_component_subgraphs(G)[0]
        # 使用分层聚类进行分隔
        partitions=hc.create_hc(H)
        # 构建块模型图
        BM=nx.blockmodel(H,partitions)

        # 绘制原始图
        pos=nx.spring_layout(H,iterations=100)
        fig=plt.figure(1,figsize=(6,10))
        ax=fig.add_subplot(211)
        nx.draw(H,pos,with_labels=False,node_size=10)
        plt.xlim(0,1)
        plt.ylim(0,1)

        # 绘制块模型
        # 使用带有权重的边
        # 以群集中包含的节点数量表示块模型中的节点大小
        node_size=[BM.node[x][&#39;nnodes&#39;]*10 for x in BM.nodes()]
        edge_width=[(2*d[&#39;weight&#39;]) for (u,v,d) in BM.edges(data=True)]
        # Set positions to mean of positions of internal nodes from original graph
        posBM={}
        for n in BM:
            xy=numpy.array([pos[u] for u in BM.node[n][&#39;graph&#39;]])
            posBM[n]=xy.mean(axis=0)
        ax=fig.add_subplot(212)
        nx.draw(BM,posBM,node_size=node_size,width=edge_width,with_labels=False)
        plt.xlim(0,1)
        plt.ylim(0,1)
        plt.axis(&#39;off&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##4.6三元组、网络密度和冲突&lt;/p&gt;

&lt;p&gt;在本章中——实际上对于本书中截止现在所涉及的所有内容——我们所讨论的都是关于包含一种类型节点和一种类型的边的均匀网络（uniform network）。但是，后面涉及的内容会变得越来越有趣。&lt;/p&gt;

&lt;p&gt;设想我们有两种类型的边而不是一种类型的边——友谊和冲突。我们也将在二元组和三元组的层面上引入更多变化。&lt;/p&gt;

&lt;p&gt;我们都已经经历过社会混乱——或者甚至曾经卷入其中。比如一对结婚很久的夫妇决定离婚，于是他们的朋友们马上面临决策的困难。置身于这对夫妇的任何一方都会感到压力，于是可能给持续很久的友谊关系带来破坏，并把一个本来联系紧密的网络分割成丈夫阵营和妻子阵营。当分裂造成的伤害被平复，建立新的友谊关系和恋爱关系的空间重新出现，于是类似的循环再次开始。
我们可以使用一些非常简单的规则来为这个过程建立模型（以下规则是有先后顺序的）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我的朋友的朋友也是我的朋友（使得一个结构洞闭合）。&lt;/li&gt;
&lt;li&gt;我的朋友的敌人也是我的敌人（使得三元组到达平衡状态）。&lt;/li&gt;
&lt;li&gt;我的敌人的朋友是我的敌人。&lt;/li&gt;
&lt;li&gt;我的敌人的敌人是我的朋友。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，从另一种角度看，规则2,3和4描述的是相同的（无向的）三元组，因此我们把它们都称之为“规则2”（如图4-12）。这些规则实际上很早就用来尝试描述文明史中的社会复杂性；第一次提及这些规则是在《圣经》当中（出埃及 23:22，在其它的章节中也曾出现）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7391/9454445573_292a308fe4_n.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-12 三元组演化的规则（伴随着冲突）&lt;/p&gt;

&lt;p&gt;让我们从一个违反了规则1或者规则2的社会网络中的行为开始：如果我们从一组互不相连的节点开始，并且以一个固定的概率随机的连接这些节点，最后我们会得到一个节点度分布为正态分布的简单的随机图（一个厄多斯随机图）。网络的密度（也就是网络中实际存在链接数量除以可能存在的链接数量）将会上升直到每个节点都和其它节点相连（一个完全图或者派系）。当然，这并没有那么有趣。&lt;/p&gt;

&lt;p&gt;让我们现在回到规则1。如果存在一个开放的三元组 A→B→C，按照某种概率，我们也将添加一条链接A→C。我们仍旧可以随机地添加链接，所以，最初这个网络将会线性地增长。直到某一个时刻达到链接的临界点，然后每个新增加的链接都会制造出一个开放的三元组。这个开放的三元组将会按照规则1的要求被闭合，其结果是制造出更多的开放的三元组，这些新增的三元组随后被闭合，这个过程将不断进行下去。&lt;/p&gt;

&lt;p&gt;在某种意义上讲，网络从线性增长过渡到指数形式的增长。它像病毒一样传播开来（图4-13）！链接的密度迅速增长，直到没有新的链接可以增加并且我们得到一个全联通的图。当然，在现实当中，对于一个网络存在一个可能的链接数量的限制，也就是饱和密度（saturation density）。这个密度可以是网络自身的特征，或者是这个网络所在的环境——或者是规则2的结果（正如在我们的模型当中）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3791/9457227340_f29cef0a30.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-13  按照规则1使三元组闭合&lt;/p&gt;

&lt;p&gt;通过改变一个友谊关系为敌对关系，冲突以一个恒定的概率被引入网络演化当中。图4-14刻画了可能的演化形式。在这个简单的例子当中，一个包含4个闭合三元组的网络被作用于其一个边上的冲突所扰动。三元组A-B-C开始因为B和C之间的冲突而变得不平衡；因此A被迫以一种随机的方式选择站在冲突双方的哪一边，并选择与B和C中的哪一个继续保持朋友关系。在A-C这条边上施加一个冲突迫使另一个三元组（A-C-D）变得不平衡，并将节点D引入到冲突中来。如果节点D选择把节点C从整个网络中孤立出来，冲突的蔓延终止。但是，如果D选择孤立节点A， 这将导致冲入进一步蔓延并破坏更多的网络链接。拥有更多的链接增加一个节点形成更多的网络链接的概率，但是也增加了两个节点之间的冲突蔓延到整个网络的可能性（如图4-14）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3803/9457227314_4b071eea92.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-14 冲突的蔓延&lt;/p&gt;

&lt;p&gt;冲突蔓延的结果是网络密度再也不可能增长到接近100%的程度；但相反，一旦它到达了一个“第二临界值”，冲突会变得更加突出（如图4-15所示）并使得网络密度降低。这类行为被称为自组织的临界性——我的模型仅仅提供一种在社会网络中生成这种效果的简单方法。这与森林火模型中的方法类似：森林的密度越大，下一场森林火演变为灾难的可能性越大——允许小的火灾降低森林密度到某种水平上使得大多数火灾被相对得很好地控制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7291/9457227330_10d6205b0c_o.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图 4-15  按照规则2运行的冲突的蔓延&lt;/p&gt;

&lt;p&gt;我们将在第6章讨论更多的网络动态——但同时，现在是开始了解包含不同类型节点的社会网络数据的时候了——这些数据更接近于我们所熟悉的社会网络。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第5章 二模网络</title>
      <link>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter5/</guid>
      <description>&lt;p&gt;在本章中，我们将探索分析具有两种及两种以上节点类型的复杂网络的方法。但首先，我们先从一个故事开始。&lt;/p&gt;

&lt;p&gt;###竞选资金是否影响选举？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“我们有一个用金钱能买到的最好的政府。”——马克•吐温&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每年四月份，在芝加哥帕尔默家园希尔顿酒店(The Palmer House Hilton)，政治科学家在中西部政治学年会（讨论特殊利益集团政治和竞选资金的顶级会议）上准备好辩论马克•吐温的话是否正确，或者美国政治系统实际上对于金钱的影响是否免疫。&lt;/p&gt;

&lt;p&gt;带着一个关于竞选资金及其对选举结果影响的大规模社会网络研究，我们 在2006年加入这场辩论。在本节中，我们将简要回顾这个研究，并介绍得出这些结果所使用的方法。&lt;/p&gt;

&lt;p&gt;但首先，让我们开始玩一个小游戏。&lt;/p&gt;

&lt;p&gt;看一下图5-1。这个图中的节点是积极卷入2000年美国国会选举和总统选举的政治组织或政治行动委员会（political action committee， PAC）。红色和蓝色的节点分别代表共和党和民主党（州和全国），绿色节点代表单个事件群体，紫色节点代表工业协会，黄色节点代表非盈利组织。政治行动委员会之间的网络链接表示它们花钱的地方——如果A和B向同一个候选人捐款，在它们之间就存在一条链接——并且他们越相似，网络链接的权重越大。权重大的网络链接在图中用粗的线条表示（我们将在稍后介绍这是如何做的）。&lt;/p&gt;

&lt;p&gt;P93
图5-1 竞选资金——政治行动委员会网络&lt;/p&gt;

&lt;p&gt;这个研究是基于依照麦肯恩-法因戈尔德竞选改革法案由联邦选举委员会所公布的数据 。这个数据是基于政治行动委员会每次向一个候选人捐款时按照要求提交的表格。这个数据在每个选举年份可从&lt;a href=&#34;http://fec.gov/获取，但是数据信息的质量和覆盖范围因选举年的政治环境的不同而存在差异。&#34; target=&#34;_blank&#34;&gt;http://fec.gov/获取，但是数据信息的质量和覆盖范围因选举年的政治环境的不同而存在差异。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正如你所看到的，单个事件政治行动委员会主导整个网络。右方是共和党群集，以共和党国家委员会（RNC）为首，而左方是民主党群集和民主党国家委员会（DNC）。但是，三个政治行动委员会紧挨着并且与这些“国家队队员”有着紧密联系，它们看上去支配着这个网络里非常多的权力。&lt;/p&gt;

&lt;p&gt;你能猜出它们是谁吗？&lt;/p&gt;

&lt;p&gt;答案在图5-2当中。在紧密相连的三元组的左方和右方的节点分别是全美堕胎及生殖权行动联盟（NARAL）和国家生命权利委员会——代表了关于堕胎问题的两个阵营，这在2000年和现在都是美国政治中最富争议的问题之一。&lt;/p&gt;

&lt;p&gt;图 5-2 竞选资金——美国政治行动委员会网络（核心网络）&lt;/p&gt;

&lt;p&gt;在中间的是美国劳工联合会—产业工业联合会（AFL-CIO），它代表了美国最大的工会和它所代表的超过一千一百万选民。这个组织在历史上倾向于支持民主党，但是共和党需要赢得重要的、像俄亥俄和密歇根这样的工业发达的州的选票以便于控制国会并让共和党候选人当选总统，这意味着要从传统选区那里吸引工会的选票。这需要一个“杠杆问题”：一个能够使得工会成员打破对于政党的附属关系的非常争议的问题，比如堕胎。&lt;/p&gt;

&lt;p&gt;可能是因为精心设计或者命运的偶然，我们现在可以说即使堕胎问题不是一个有争议性的问题，也是一个影响2000年大选的少数问题之一 。&lt;/p&gt;

&lt;p&gt;一点点额外的娱乐，我想要你注意一下图 5-2中做下角。这一个政治行动委员会的群集（除了纽约州民主委员会（New York State Democratic Committee）之外）仅仅为了一个原因而存在——打败希拉里•克林顿（Hillary Colinton）。&lt;/p&gt;

&lt;p&gt;我们将再稍后重新回到这个竞选数据，但首先让我们看一下如何来完成这些研究。&lt;/p&gt;

&lt;p&gt;###二模网络的理论&lt;/p&gt;

&lt;p&gt;现存的大多数网络数据都是二模的（双峰的或双向的）形式——也就是说，存在两种不同类型的节点，并且网络链接表示一群节点和另外一群节点之间的关系。&lt;/p&gt;

&lt;p&gt;例如，一个数据当中可能包含多种关系，例如政治贡献（例如政治行动委员会资助候选人）、雇佣关系（个体被组织所雇佣）或社会化媒体使用行为（用户对某些页面的喜爱）。这些网络经常包含两种以上类型的节点，例如天使投资人向创业者所创建的公司投资（这更有趣，因为成功的创业者最后自己也成了天使投资人）。但是，方法基本没有什么改变。&lt;/p&gt;

&lt;p&gt;社会学家提出一个概念：个体和群体的二元性 。从本质上讲，这个概念是指人们的想法、态度和社会关系是由个体在群体中的身份所决定的，而群体的形成源于是由成员的态度。这适用于公司、帮派、政党、社交俱乐部等。因为人们往往不仅具有一种群体成员身份，群体成员的身份可以被看作一种分析和汇总个体之间的相似性和差异性的一种方法。&lt;/p&gt;

&lt;p&gt;###隶属网络 ( affiliation network )&lt;/p&gt;

&lt;p&gt;图 5-3 展示的是一个简单的二模网络——个体A和B都是一个俱乐部的成员。这实质上构成了一个开放式的三元组，或者一个结构洞——但我们可以推断如果A和B是同一家俱乐部的会员，他/她们可能知道彼此，因而推断这个三元组实际上是闭合的。这当然是一种很弱的推断：举一个更具体的例子，还应该考虑A和B是否在同一个时间段里是这个俱乐部的成员，或者这个俱乐部在不同的城市里有多个分会，等等。但这只是一个开始。&lt;/p&gt;

&lt;p&gt;图 5-3 三元组的闭合与共同成员身份&lt;/p&gt;

&lt;p&gt;现在想象一个人是多个俱乐部的成员（在图5-4中，节点E，F,H是两个俱乐部的成员）。据此我们可以推断他们之间存在较强的联系，或许暗示着一种共享的群体身份。我们可以继续增加成员关系直到我们确信这些联系是真实的，并给推断出的链接赋予权重。&lt;/p&gt;

&lt;p&gt;图 5-4 从二模网络中创造一个隶属网络&lt;/p&gt;

&lt;p&gt;图 5-4 展示了由原始的二模网络推断出来的两个网络——一个是是由个体之间共享的群体身份决定的人际网络，另一个是不同的组织之间所共同包括的成员所决定的群体网络。创造这种网络，我们只需要统计每个人或每个俱乐部的共享成员身份的数量。&lt;/p&gt;

&lt;p&gt;正如其它的社会网络一样，这些网络也可以采用相同的分析方法，并且非常适合采用“岛屿方法”（参见第四章 网络上的岛屿 一节）和聚类方法（参见第四章 分层聚类 一节）。这是因为这些网络实质上是基于相似度或者相关程度的网络，因而其意义很容易理解。&lt;/p&gt;

&lt;p&gt;###属性网络&lt;/p&gt;

&lt;p&gt;二模网络分析的另外一个应用是基于同质性（homophily，希腊文， “喜欢相似的人或物”）的想法——这个想法认为相对于具有不同兴趣或属性的人，具有相同兴趣或属性的人倾向于和相似的人交流并建立联系。那么如何理解“异性相吸”等说法呢？这个理论似乎适用于一些情况，但并不适用于另外一些情况，因此这个理论并非是一个普适的法则。我们也知道如果人们更紧密地在一起，他们就会在意见、观点上更相似——但这种影响存在一定限度的。&lt;/p&gt;

&lt;p&gt;但是，如果你想要建立一种线上社会网络里的朋友推荐机制，把属性矩阵或兴趣矩阵转化为一个二模网络是一个有用的方法。所需要做的就是把每一份信息（标签、关键词等）看作是二模网络中的节点，从中得到一个人和人之间的隶属网络，应用岛屿方法或者聚类方法找到潜在地属于同一个群体的人。在此基础上推荐朋友，只需要从隶属网络中挑选最强的网络链接。&lt;/p&gt;

&lt;p&gt;一个（与二模网络）逆向的隶属网络——用属性作为边来连接个体——能够提供更多有趣的洞察。试想我们想要测量推特上的政治话语。我们提取包含“选举”这个井号标签（#， hashtag）的由几万人所发的推特，构造一个从使用者个体到井号标签的二模网络，并在此基础上计算一个“用井号标签作为边连接个体”的隶属网络。在这样的网络中，群集成为整个话语空间的中介——并能够将推特使用者区分为自由和保守两派。进一步的分析可能这两个派系内部相互分隔的原因，比如茶党作为一个独立的主体涌现并分布于主流的共和党的话语中。&lt;/p&gt;

&lt;p&gt;###一点数学&lt;/p&gt;

&lt;p&gt;让我们用一个邻接矩阵来表达一个网络（参考 第二章 邻接矩阵 部分）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      1 2 3 4 5
    A 0 0 0 0 1
    B 1 0 0 0 0
    C 1 1 0 0 0
    D 0 1 1 1 1
    E 0 0 1 0 0
    F 0 0 1 1 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，让我们比较节点D和F;我们可以通过将这D、F两行在表格中相乘的方法来完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      1 2 3 4 5 Sum
    D 0 1 1 1 1 = 4
    F 0 0 1 1 0 = 4
  D*F 0 0 1 1 0 = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D和F共享两个边。现在我们来对任意一对节点进行上述操作，并将它们放在一个如下的矩阵中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      A B C D E F
    A 0 0 0 1 0 0
    B 0 0 1 0 0 0
    C 0 1 0 1 0 0
    D 1 0 1 0 1 2
    E 0 0 0 1 0 1
    F 0 0 0 2 1 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的这个邻接矩阵代表了节点A到F所构成的隶属网络，并且这个操作仅仅需要做矩阵的乘法。在这个练习中，我们将邻接矩阵A和其转置矩阵（At）相乘：AA=A* At&lt;/p&gt;

&lt;p&gt;【警告标志】在本书中，我们采用一种在数学上并非严格定义但是可读性好的概念：一个包含人和俱乐部的二模网络被称为PC；由这个网络得到的人和人相连的隶属网络称为PP，等。&lt;/p&gt;

&lt;p&gt;这个计算需要花费较多的时间。实际上，这个操作的计算复杂性是O(n*m*n)。其中n是“外边界”（在这个例子中是政治行动委员会），m是这个乘法的“内边界”。从一个10*5的二模的网络中提取隶属网络需要在矩阵的“长边”进行10*5*10=500次操作，在矩阵的“短边”上进行5*10*5=250次操作。在这种情况下，一次操作需要在一个找到给定两个节点a和b的边（a,b）的取值，并且如果如果这个操作需要对文本进行操作，得到隶属网络的计算将会变得非常昂贵。合理的索引（使用Python的词典或者SQL的索引）可以使得这个操作变得很快，一般可以将计算时间减少2或3个数量级。&lt;/p&gt;

&lt;p&gt;【警告标志】如果你以前未接触过矩阵代数（我承认它非常枯燥，虽然也非常有用），可按照如下方法思考矩阵乘法：如果我们用PC乘以CP，“内边界”（P）必须相同。两个矩阵的内部边界相互抵消，我们将得到一个方阵CC。那么AB*BC*CD*DA等于什么呢？AB*BC=AC;AC*CD=AD;AD*DA=AA;我们走过了一个循环。这种创造一个长的相乘的序列的特性在第XX页的“扩展多模网络”一节中变得非常有用。&lt;/p&gt;

&lt;p&gt;###二模网络实战&lt;/p&gt;

&lt;p&gt;NetworkX提供另一个很多用于二模网络的函数。使用这些函数，需要安装版本为1.5或者更高版本的NetworkX。让我们尝试一个简单的例子。&lt;/p&gt;

&lt;p&gt;所使用的数据来自于我们前面所提到的竞选资金数据的一部分。原始的数据包含50万次交易。我们仅仅使用基于几百个交易数据所构建的二模网络。在这个例子中，每个政治行动委员会和每个候选人都被分配了一个编号(ID)。实际上，这些独特的编号是由联邦选举委员会给定的。候选人的编号实际上非常容易辨识。例如，候选人H6IL14095Z在第14区、参选伊利诺伊州（ILlinois）的众议院（House）——这些信息足够帮助我们找到这个候选人是共和党人丹尼斯∙哈斯泰特（Dennis Hastert）。联邦选举委员会同时也提供一个包含所有候选人信息的详尽数据库（具体到候选人的家庭住址） ，但我们在这本书中将不会分析这个数据（因为涉嫌网络跟踪）。&lt;/p&gt;

&lt;p&gt;我们将要使用的数据存储为CSV（逗号分隔）格式（见表 5-1），包含了我们所需要的所有变量，其中一些变量我们现在不会考虑。第一列是每个行动委员会的编号，第13列是收到捐款的候选人的编号，第11列是捐款的金额。2000年的数据格式与现在的数据格式可能存在一些差异，但基本上一致。你可以通过修改以下代码的方式来分析现在的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import csv
import math
import networkx as net
## 引入二分（双峰）函数   
from networkx.algorithms import bipartite as bi
## 从csv文件中读取数据
## 我们使用rU模式读入数据，因为很多CSV文件是通过Excel创造的
r=csv.reader(open(&#39;campaign_short.csv&#39;,&#39;rU&#39;))
## 二模网络通常是有向的。这里边的方向表示资金流动的方向
g=net.Graph()
## 我们需要分开追踪不同类型节点
pacs=[]
candidates=[]
## 使用CSV文件中的边构建一个有向的图  
for row in r:
    if row[0] not in pacs:
    pacs.append(row[0])
    if row[12] not in candidates:
    candidates.append(row[12])
    g.add_edge(row[0],row[12], weight=int(row[10]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表 5-1 竞选资金交易记录（前20行）&lt;/p&gt;

&lt;p&gt;###政治行动委员会网络&lt;/p&gt;

&lt;p&gt;现在我们已经构建了一个图对象，我们能用它做什么呢？让我们开始计算一个政治行动委员会网络的隶属网络：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacnet=bi.weighted_projected_graph(g, pacs, ratio=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个网络有一个大的组元和一些孤立的节点。这些孤立的节点是我们随意地去除一部分数据用作例子的人为产物——并且我们同样可以在这里把它们扔掉，而仅仅保留那个最大的连通的组元：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacnet=net.connected_component_subgraphs(pacnet)[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要画出最后的这个网络，并且通过颜色和边的宽度来展现关系的强度。因为边的取值范围非常广，所以需要使用取其对数的方法来压缩其数值范围:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;weights=[math.log(edata[&#39;weight&#39;]) for f,t,edata in pacnet.edges(data=True)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们将画出这个网络图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.draw_networkx(p,width=weights, edge_color=weights)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个图应与本书中的图5-5相似。粗的红色边代表强关系；在这个数据当中，最强的关系存在于节点C00000422和C00000372之间，前者是哥伦比亚的克雷格∙安德森（Craig Anderson）博士，后者是道路维护政治联盟——一个位于密歇根州绍斯菲尔德地区的铁路工人工会组成的政治行动委员会。&lt;/p&gt;

&lt;p&gt;###候选人网络&lt;/p&gt;

&lt;p&gt;为了计算候选人网络，我们需要简单地逆转投射的方向并根据候选人表格而非政治行动委员会表格来计算一个投射的隶属网络。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cannet=bi.weighted_projected_graph(g, candidates, ratio=False)
cannet=net.connected_component_subgraphs(cannet)[0]
weights=[math.log(edata[&#39;weight&#39;]) for f,t,edata in cannet.edges(data=True)]
net.draw_networkx(cannet,width=weights, edge_color=weights)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果得到的图要明显大得多并需要花费更长的时间绘制出来。它看上去有些像一个毛球 。非常明显，这个网络存在着一些明确的群集；我们现在将要使用第xxx页“网络中的岛屿”一节中提到的“岛屿方法”。首先，让我们看一下边的数值的柱状图——这将帮助我们确定“水平面”的大小。图 5-6表明大约80%的边的权重小于0.9，所以我们可以安全地去掉它们：&lt;/p&gt;

&lt;p&gt;P102&lt;/p&gt;

&lt;p&gt;图 5-5 政治行动委员会的部分隶属网络&lt;/p&gt;

&lt;p&gt;图 5-6 国会候选人网络中边的权重的柱状图&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def trim_edges(g, weight=1):
    g2=net.Graph()
    for f, to, edata in g.edges(data=True):
        if edata[&#39;weight&#39;] &amp;gt; weight:
            g2.add_edge(f,to,edata)
    return g2
plot.hist(weights)
## 这个柱状图中的边的权重是取对数的；
## 我们可以计算初始的权重=e^log_weight
cannet_trim=trim_edges(cannet, weight=math.exp(0.9))
## 基于这个新网络重新计算
weights=[edata[&#39;weight&#39;] for f,t,edata in cannet_trim.edges(data=True)]
net.draw_networkx(cannet_trim,width=weights, edge_color=weights)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个核心的网络（图 5-7）清晰地包含着一些由跨越边界的候选人联系在一起的紧密的群集。在2000年的时候，许多民主党人趋于保守——结果导致使得他们从一些共和党支持者那里获得很多资金。这当然未能使得他们赢得选举。&lt;/p&gt;

&lt;p&gt;图 5-7 国会候选人网络（核心）&lt;/p&gt;

&lt;p&gt;P 104&lt;/p&gt;

&lt;p&gt;从现在开始，我们可以使用分层聚类的方法（见第XXX页“分层聚类”一节）来寻找处于这些群集的人。跨越边界者可以通过使用中介中心度（见第XX页“寻找传播的瓶颈和/或社区的桥梁”一节）。因为这些方法已经在前面的章节中讲过，我们把这一部分作为留给读者的练习 。&lt;/p&gt;

&lt;p&gt;###扩展多模网络&lt;/p&gt;

&lt;p&gt;在前面几节当中，我们讨论了如何处理二模网络。但是，我们都知道这个世界其实更复杂，网络中的节点和边的类型非常多。幸运的是，我们在之前的几节中讨论的方法可以很容易的扩展到任何网络数据模型中。我们只要小心地确保每个网络以及隶属网络的意义是什么——并且不会再矩阵乘法的海洋中迷失。&lt;/p&gt;

&lt;p&gt;我想要用取自大卫∙魁克哈特（David Krackhardt）和凯思琳∙卡莉(Kathleen Carley) 的一个研究中的关于一个组织的数据模型作为一个例子。&lt;/p&gt;

&lt;p&gt;让我们想象ACME公司，一个制作装饰品的一个小公司。一些人通过某种彼此传达命令的形式正在为这个公司工作。这些人在公司内部和外部都存在友谊关系，在某个专业领域里受过正式的教育，并拥有一些资源。公司所生产的装饰品包括一些部件或分拆的任务，其中每一个单独的任务都需要一些人运用一种技能和资源才能完成（例如，制作一个链轮齿，一个人需要了解如何操作车床，具有钢原料，并花费足够多的时间）。&lt;/p&gt;

&lt;p&gt;你是否注意到所有的黑色斜体的词？从多模网络而言，这些词都可以被看作是节点，在此基础上，我们可以构建一个代表了ACME的社会网络，有些像图 5-8。图 5-8中的实体-关系示意图仅仅展现了组合中的四种实体，这种关系图可以变得非常复杂。在这个例子中，我们不会穷尽所有可能的关系——但我么将说明如何得出新的推论的方法（这种方法适用于其它的场景）。&lt;/p&gt;

&lt;p&gt;P 105&lt;/p&gt;

&lt;p&gt;图 5-8 一个简单组织的实体-关系示意图&lt;/p&gt;

&lt;p&gt;以一种矩阵的形式，这个组织模型看上去像表格 5-2。&lt;/p&gt;

&lt;p&gt;表格 5-2 作为一个邻接矩阵的实体和关系&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;人(P)    技能(S)   资源(R)   任务(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;人(P)  PP：谁了解谁？    PS：谁了解什么？   PR：谁拥有什么？   PT：谁做什么工作？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;技能(S)     SS：什么样的技能同时被需要？ SR：某一种资源需要什么技能？ ST：一个任务需要什么样的技能？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;资源&amp;reg;         RR：什么资源同时被需要？   RT：一个任务需要什么资源？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;任务(T)             TT：任务之间的优先次序&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个矩阵都只不过是记录着乔（Joe）在多大程度上了解如何操作车床或者乔是否有铁原料制作链轮齿的一个表格。&lt;/p&gt;

&lt;p&gt;我们现在可以把以前几节中的每一个网络看作一个二元网络（bipartite network）。不幸的是，NetworkX尚未为分析多元网络（multipartite network）提供一个扩展的函数，所以我们必须回到矩阵的水平上进行计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import numpy as num
pc=net.adj_matrix(g)   #从网络中提取邻接矩阵
cp = pc.transpose()   #得到转置矩阵
cc= pc*cp   # 计算一个政治行动网络之间的网络
cc_graph = net.Graph(cc)   #从一个邻接矩阵中重新创作一个NetworkX对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们好好玩一下。因为我们可以进行无限长度的矩阵乘法以满足我们的需求，所以我们可以对数据进行很多的推论。比如：&lt;/p&gt;

&lt;p&gt;• PP * PP = PP: 这个心的网络的意义是“谁是朋友的朋友？”&lt;/p&gt;

&lt;p&gt;• PT * PTt = PT * TP = PP: 它的意义是“谁和谁在一起工作，完成多少任务？”&lt;/p&gt;

&lt;p&gt;• PT * TT = PT: 对每个人来说，对于他们来说至关重要的是那些任务？&lt;/p&gt;

&lt;p&gt;• TT * TT = TT: 相互依赖的任务&lt;/p&gt;

&lt;p&gt;• PT * TT * TP = PP:对一个人来说至关重要的是哪些人？&lt;/p&gt;

&lt;p&gt;• PT * TT * TT’ * TP = PP: 对于同时进行的任务，那些人在一起协同工作？&lt;/p&gt;

&lt;p&gt;####练习&lt;/p&gt;

&lt;p&gt;在这个模型当中，你如何判断那些任务是不可能完成的？让我们假设一项任务可以被完成如果被委派完成此任务的人拥有完成这个任务的资源。&lt;/p&gt;

&lt;p&gt;【警告标志】这个方程RTt* PRt = TR * RP = TP代表能够被一个人完成的任务。这个方程TP * PT = TT将生成一个矩阵。这个矩阵的对角线完成一个任务可能存在的方法的数量。如果这个数字是0表明这个任务是不可能完成的。&lt;/p&gt;

&lt;p&gt;可计算的组织理论的整个领域环绕着这种类型的模型成长起来。正如许多其它的模型，不管是静态的还是动态的，本书开始部分关于恐怖主义者网络的模拟是根据类似的原则（但在更高的水平上）建立的。资源分配和可行性评估现在已成为微软项目的一部分。&lt;/p&gt;

&lt;p&gt;这里有一个警告如果有人想要在咨询实践中使用这种方法。不管现在运行多么完好，没有一个商业拥有它的商业模型、社会网络、嵌入雇员的心智中的知识的完全信息。一些人想要通过积极地改造企业的结构的方式来巩固其组织模式——但是，正如我们在前面讲到非正式网络时提到过的，这将被非正式的组织结构直接规避。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第6章 信息扩散：像病毒一样传播开来</title>
      <link>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/zh/post/cn/2012-07-01-snabook-chapter6/</guid>
      <description>&lt;p&gt;这一章或许是你挑选这本书的首要原因。很多人好奇事物（视频、网站、新闻等）如何像病毒一样在网络上传播开来——迅速扩散并成为文化中的一部分（同时在这个过程中，使得创造它们的作者富有）。我们应该预先告诉你我们并没有现成的答案。实际上没有任何人知道答案，并且这个过程中有一些运气的成分在——但在本章中，我们将要尝试使你更加理解驱动扩散的原因以及你的决策如何驱动购买行为。&lt;/p&gt;

&lt;p&gt;##6.1病毒视频剖析
假设给你的猫拍摄了一段非常可爱的视频，上传到YouTube网站上并通过推特进行宣传。你是否正走在通往财富的道路上？答案是，不一定。&lt;/p&gt;

&lt;p&gt;这主要取决于谁看到了这个视频，以及他们在看完之后做了什么。首先，唯一看到视频的是位于你的自我中心网（ego network）中的成员——比如你的朋友。这样的观看总数的增长是非常缓慢的；观看总次数随着时间是线性增长的，这意味着每个时间段的观看次数接近一个固定常数。在这种情况下， 我们可以将观看次数描述为一个泊松过程，其中的每个观看你的视频的浏览行为彼此之间是独立的。最后，你的视频所获得的总浏览数量与你的粉丝的数量（你的程度中心性）存在数学上的关联。&lt;/p&gt;

&lt;p&gt;但如果发生了一些其它的事情并且你的朋友们转发了这个视频给他们的朋友（等等，使得越来越多的人知晓这个视频），你的猫的视频将马上成为YouTube上面最流行的视频，并且好莱坞的制片人前来你家拜访。或者这一些都没有发生。&lt;/p&gt;

&lt;p&gt;有一个奇怪的事情在这个过程中间的某处发生了。你的一个朋友说“你看过这个视频吗？”，另一个朋友回答“是的，我已经看过了”，这强化了这个视频是一个“觅母”（meme） ——一个新的、独立的文化人造产品的观念。突然之间，让别人接触这个觅母就成一个人的第二天性或者甚至是一种必须的行为。&lt;/p&gt;

&lt;p&gt;从一个无足轻重的事物（但是可爱或有趣）变成一个必须分享的事物的质变过程是增长曲线的一个剧烈的转折，也被称为“临界质量”（critical mass）。如果在一定量的时间里，觅母未能在一定的时间范围里到达临界质量，它的采纳率开始下降并最终消亡。&lt;/p&gt;

&lt;p&gt;但是如果到达了临界质量，它将指数增长直到达到饱和点——也就是几乎每个可能采纳这个觅母的人都已经采纳。从这一点开始，觅母将会开始走下坡路。&lt;/p&gt;

&lt;p&gt;需要注意的是临界质量和饱和的概念适用于每个网络和社群——一个觅母在一个社群到达饱和点而在另一个社群里无人知晓是可能的。但是，因为社群是相互连接的，所以觅母通过跨界者从一个社群传入另一个社群并确立一个新的临界质量和更高的饱和点是可能的。&lt;/p&gt;

&lt;p&gt;###脸书做对了什么
在脸书（Facebook）出现之前，存在着其它社会网络。我们中的一切人或许还有聚友网（MySpace）的账号。一些人还记得Friendster。在Friendster之前，在所有其它SNS之前还有一个叫SixDegrees的网站。SixDegrees创立于1997年，它承诺将连接人们和他们的朋友、以及他们的朋友之间、最好的律师、医生、水暖工等。这样做，它将提供帮助人们通过社会网络完成任务的有用的功能。&lt;/p&gt;

&lt;p&gt;SixDegrees早于时代5年时间，并且尽管采用了全国范围内的广告宣传、良好的设计（对1997年而言）、在博客（令人尊重的Slashdot网站和波音波音（BoingBoing）网站都曾重点推介过它）和杂志（连线杂志）中良好的形象，它从未迎来增长的临界点。&lt;/p&gt;

&lt;p&gt;哪里出错了呢？答案非常简单——Sixdegrees未能到达它的临界质量。网站本身是全国性的，他们却实际上试图建立一个蔓延全国的地方化的市场，结果未能完成这个任务——实际上几乎不可能在这个网站上找到一个水暖工，部分原因是那时很少有水暖工使用互联网（或者觉得建立一个网络SNS账号很麻烦），部分原因是SNS的使用强度非常低。&lt;/p&gt;

&lt;p&gt;当脸书2003年建立的时候（仍使用最初的名字“Facemash”），它是一个哈佛本科生组成的小而紧密的网络社群。创立于一个较小的地区使得他们可以快速到达增长的临界质量。实际上，在它上线约四个小时内，就已经吸引了450个访问者，或者大约6%全部的本科生。记住6%这个数字，它非常重要。&lt;/p&gt;

&lt;p&gt;在哈佛内部，早期的脸书经历了一系列反复，直到找到一个易于扩展的设计并最终覆盖50%的哈佛本科生而达到饱和。从那开始，它的触角开始伸向其它常青藤高校，一个接一个，最终覆盖了美国所有大学。最后在2005年，它开始面向高中生——并奠定了它主宰世界的基础。&lt;/p&gt;

&lt;p&gt;脸书所遵循的规则——也是脸书不同于Sixdegrees和Friendster的地方——是在一个社群里到达饱和点之后才移入一个更大的社群。通过这种方式，临界质量从未被错过，并且新的成员完美地嵌入他们来自其他学校的伙伴建构的社会结构之中。&lt;/p&gt;

&lt;p&gt;###如何估计临界质量
在“三元组、网络密度和冲突”一节中，我们讨论了冲突如何在社会网络中蔓延及其对于网络链接的密度的影响。如果你回去重新仔细看图4-13，你会发现一个非常相似的增长方程——相同的S形曲线，如同我们在图 6-1中所观察到的一样。&lt;/p&gt;

&lt;p&gt;图 6-1 扩散曲线——临界质量、繁荣和萧条&lt;/p&gt;

&lt;p&gt;图字翻译：&lt;/p&gt;

&lt;p&gt;如果从线性的蔓延到指数（病毒式的）增长的确依赖于封闭的三元组（也就是说，朋友的朋友也是我的朋友）  ，这样连接的临界质量的可以通过测量随机增加一个链接（比如，从A到B）与其它节点之间所形成的一个或多个开放三元组的概率的方法加以估计。这个概率与已经彼此相连的节点的数量（我们用2与节点数量相乘是因为每个边占用两个节点）：&lt;/p&gt;

&lt;p&gt;P(开放三元组) ~= 链接的数量/(2*节点的数量)&lt;/p&gt;

&lt;p&gt;这样，当四分之一的节点彼此相连的时候构成一个开放的三元组概率是50%——并且每一个新的链接使得闭合三元组能够创造甚至更多的链接，进一步增加形成级联（Cascade）的概率。&lt;/p&gt;

&lt;p&gt;我们在实验中发现当网络密度接近7%的时候将从线性增长（每一次增加一条链接）转化为病毒式扩散——也就是说，当有意采纳这个“觅母”、转发一个视频、加入一个网络社群等的人的比例达到7%的时候，其他人将会在关键阶段马上跟进。&lt;/p&gt;

&lt;p&gt;这是一个推动脸书走出哈佛的、神奇的数字。在我们的研究过程中，我们发现的一些其它的例子也表明当网络中的采纳比例小于10%时会发生病毒式扩散。&lt;/p&gt;

&lt;p&gt;从这一点可以得到的一个推论是在一个较小的社群里更容易达到临界质量——马克•扎克伯格（Mark Zuckerber）本能地知道或者（更可能）偶然发现。&lt;/p&gt;

&lt;p&gt;tips：
对于一个新兴公司（尤指新兴网络公司）的创立者而言，这是违背直觉的。每一个风险投资者都想知道整个市场到底有多大以及新兴公司完成市场渗透的计划。追逐小的自给自足的细分市场看上去与指数式的增长背道而驰。但是，一个细分市场的高饱和度是通往其它细分市场的一个好跳板——如果它们在地理上接近或者其利益非常吸引人。&lt;/p&gt;

&lt;p&gt;###维基经济的临界质量
关于临界质量的问题还有一种看法——参与成本理论。即使在一个提供免费服务品的世界，任何事物都有成本。这种成本包括金钱成本、时间成本、或者机会成本（也就是说，花费时间在脸书上，就无法花费时间在酒吧里——至少在移动手机变得普遍之前）。其它形式的参与文化，比如维基百科，需要其作者和编辑花费更多的时间，但得到的收益却非常短暂。&lt;/p&gt;

&lt;p&gt;一个过时但依然有说服力的例子是传真机的出现。当第一个传真机在上世纪七十年代中期，从施乐的装配线上生产出来之后，其成本高达几千美元并且完全得没有什么用处。另外不要忘记，如果一个传真从它那里发出，并没有位于另一端的一个传真机接受它。当第二台传真机在几分钟之后从生产线上滑落的时候，两台传真机的价值都无限增加了——现在一个银行可以（通过传真机）与其分支网点通讯了。但是，这台机器的用处随着越来越多的机器被生产出来而不断增加，直到传真机成为一种不可或缺的办公用品。&lt;/p&gt;

&lt;p&gt;在传真机的例子中，传真机最初被应用于大公司的总部连接其分支机构（代替了庞大的电传机）。所以每个公司独立地、按照自己的时间到达它们自己的临界质量——如果公司已经投资足够多资金到传真机设备上，在更大的范围销售传真机将会变得非常困难或者不可能。
一个经济学家会使用交易成本的概念讨论这件事情，并画出如图 6-2的曲线。&lt;/p&gt;

&lt;p&gt;图 6-2 成本曲线——社会化媒介的经济学&lt;/p&gt;

&lt;p&gt;图字翻译：&lt;/p&gt;

&lt;p&gt;假设参与成本是一个固定的值。在一些例子中（例如，传真机），当大规模生产时生产成本降低，但在参与式的文化（例如，维基百科）中，成本实际上随着生产规模膨胀而变大了——但我们可以在短期里认为它是常数。&lt;/p&gt;

&lt;p&gt;对于一个早期采纳者而言，成本是非常真实的，而利润还没有实现。当有更多人加入这个网络之后，收益以连接的数量的函数的形式增加，这使得新观念、觅母、社会网络网站的渗透漫漫长路中的每一步都变得更为容易。&lt;/p&gt;

&lt;p&gt;当使用一个产品带来的收益超过其成本的时候，扩散将接近临界质量。此时，每增加一个链接将会带来更多的链接，进一步增加收益——而成本却保持不变。&lt;/p&gt;

&lt;p&gt;如果没有到达成本/收益的平衡点，在网络中存在多少链接都是没有意义的——因为，最终在这个网络中的扩散都会失败。&lt;/p&gt;

&lt;p&gt;###内容（依旧）为王
当我开始1995年开始为网络项目而工作时  ，曾经有一个说法叫做“内容为王”。内容可以吸引使用者、留住使用者、挽回使用者。那时候流行很多理论——其中一个说应该确保用户点击鼠标不超过6次就能够找到他/她想要的内容，另一个说重要的信息不要被屏幕翻页所分割（载入的计算机屏幕的第一页之后部分信息）。不管是在过去还是在现在，这些都是好的设计准则。但是如果网站的内容非常吸引人，其它的这些都不再重要。如果翻页后的内容很有价值，人们就会点击和滚动鼠标去看。&lt;/p&gt;

&lt;p&gt;这种观点在今天同样存在：如果内容在某些方面是引人入胜的，这将提高收益并使得成本和收益的平衡更快到达，并因此将链接的临界质量从7%降低到3%或4%。如果内容的质量不是那么好，那么可能根本就无法到达临界质量。&lt;/p&gt;

&lt;p&gt;这是社会网络的定量分析止步的地方，也是关于信息重要性的理论过度盛行的领域。下面的这个理论是许多试图定性地解释信息扩散的一种方式。&lt;/p&gt;

&lt;p&gt;当我们想要知道一个信息是否可以在一个网络中扩散时，实际上我们的问题是“这个信息是否会和网络中的成员引起共鸣？”。或者，更准确地说，“个体如何获取信息？”。我们可以将信息的作用分解为几个维度的变量：&lt;/p&gt;

&lt;p&gt;•   相关性（Relevance）
 我是否关心？（以及其变体，显著性（saliency）——我现在是否在乎？）&lt;/p&gt;

&lt;p&gt;•   共鸣（Resonance）
 信息的内容和我所相信的内容是否一致？&lt;/p&gt;

&lt;p&gt;•   严重性(Severity)
 信息的内容有多好或多坏？&lt;/p&gt;

&lt;p&gt;•   紧迫性（Immediacy）
 这个信息是否需要（人们）马上行动？与严重性一起，表示（看到信息后）不做出任何行动的后果。&lt;/p&gt;

&lt;p&gt;•   确定性（certainty）
 这个信息的效果是否会导致某种痛苦或者快乐？或者这种概率非常小？&lt;/p&gt;

&lt;p&gt;•   信源（source）
 信息来自哪里？我是否信任发出信息的人？这是否曾被人们所验证？&lt;/p&gt;

&lt;p&gt;•   娱乐价值（Entertainment value）
 信息是否好玩？是否耐读？&lt;/p&gt;

&lt;p&gt;###异质性偏好
我在以前的小节中的提到的评价方式适用于特定的信息（m）和人（p）。但是在实际生活当中，每个收到信息的人按照他们自己特殊的偏好来给信息打分。在经济学中，汇总异质化的个体偏好是一个困难的问题。为了简化这个问题，让我们假设以上所提到的所有变量都可以写成数值形式（我们规定其范围为0到1）。那么，每条信息都可以被评价为：&lt;/p&gt;

&lt;p&gt;公式6-1&lt;/p&gt;

&lt;p&gt;公式6-2&lt;/p&gt;

&lt;p&gt;Beta数值代表对于一个具体的个体，当他/她采用一条信息时每一个变量的重要性。有些人非常脆弱、害怕恐吓战术（具有很强紧迫性和严重性的信息，即使相关性不高并且也不相信信源），而有些人当信息来自于他们并不完全相信的信源时，毫不犹豫拒绝相信。&lt;/p&gt;

&lt;p&gt;让我们看一下是否我们可以将这个公式应用于一些可能的场景中去：&lt;/p&gt;

&lt;p&gt;####突尼斯和埃及革命
这些事件高度依赖于信息的扩散。在这个例子中，大多数信息可以被评价为高相关性、高紧迫性，一些信息会被评价为高严重性（比如，军事活动或者警察镇压活动中的信息）。但是，在任何一个像这样的快速改变的条件下，确定性很低并且对于信源的可信性超过信息本身的可信性。也就是说，一条来自你的阿姨的话比来自一个记者的信息更可信。谣言泛滥，并且有时候误导了许多人。&lt;/p&gt;

&lt;p&gt;这样，我们能够解释每一场革命都需要一个前后一致的领导——在一个混沌的时代，一条来自领导人的信息既负载着确定性（因为领导者肯定具有更多的信息或者令人信服的假信息），也负载着对于信源的超凡的信任。&lt;/p&gt;

&lt;p&gt;####保罗∙里维尔的乘骑
保罗•里维尔（Paul Revere）（1735年1月1日——1818年5月10日）是一名美国银器匠，也是美国革命战争中的爱国者。他最出名的事迹是在莱克辛顿和康科德之战前通知当地殖民军英军即将到来。（译者补注）这是关于高严重性、高紧迫性、高相关性、高确定性信息的一个最好的例子。即使信源并不太出名，信息很快就到达了临界质量。共鸣非常高，因为人们已经相信英国人的袭击迫在眉睫。有必要注意的是保罗∙里维尔并非是向世界发出一条微博，而是造访一系列的城镇——到达一大群分散的、小的地方的临界质量，这些地方稍后团结起来一起反抗英国军队。
####电视广告
电视广告对大多数读者（一些正在选择新的、正在播出的电视的人例外）来说相关度不高，重要性不高，迫切性也不高。为克服这些缺点，广告主需要设计信息内容以提高信息的确定性（例如，“这将改善你的生活”）、信源的可信性（“六个医生有五个会推荐……”）、信息的娱乐价值。对于二手车销售者来说，其它的策略也很合适，例如放大严重性和迫切性（“现在行动，否则就没有机会了”）。&lt;/p&gt;

&lt;p&gt;对于广告的响应一般非常低，因为很多人对于品牌名字漠不关心。当然，在这种情况下，能够对抗这一规律的品牌将占据市场的主导地位。苹果公司花费数年时间和几百万美元培养了一群粉丝，正如多数体育队和一些其它公司所做的那样。迎合粉丝的品牌成功地获取回报，即使信息内容很普通——只要这些信息强化了粉丝已有的信念（我们将在本章“Python中的一个简单的动态模型”一节中讨论具体内容）。&lt;/p&gt;

&lt;p&gt;最后，多数广告无人理会——但是偶尔会有一个广告超出广告商的宣传活动，像病毒一样在互联网上传播。这经常意味着广告具有较高的娱乐价值并且值得人们在它上面花费时间（参照前面关于成本/收益分析部分），即使它不具备其它方面的因素。&lt;/p&gt;

&lt;p&gt;####连锁信
连锁信是这个类别中的一个奇特成员。来自于你认识并信任的人的信息非常重要。它通过一个好故事的娱乐价值吸引你，但如果你不转寄这封信会有严重和紧迫的后果。在这种情况下，造成伤害的确定性很低 ，但转寄电子邮件的成本同样很低(如果这个信件是真的呢？)。
####搞笑猫图片
我不知道说什么好。从个人来讲，我不认为它们值得下载，但我猜我不是一个互联网媒介的典型消费者。对于一些人来说，搞笑猫图片的娱乐价值非常高，以至于你不仅仅满足于欣赏它们或者传播它们，还要去创造新的图片。我手上有额外的时间吗？&lt;/p&gt;

&lt;p&gt;许多其它的信息以相同的方式传播——思考一下宗教类的信息并且把天主教信息和热心的牧师的话对比。虽然信息的内容或许相同，信息所表达的意义却完全不同。有的信息强调商品的价值，有的信息剖析最新的流行时尚。&lt;/p&gt;

&lt;p&gt;##6.2信息如何影响网络
信息、观念和看法的改变相对得很快，并且在这个过程中，影响网络解构。同时，网络结构也制约着信息扩散的过程。结果构成了一个双重反馈回路：社会结构影响信息扩散，而信息则影响社会结构的变化。在这一节中，我们将要讨论内在机制——并尝试构建一个信息扩散的简单的动态模型。&lt;/p&gt;

&lt;p&gt;##具有相同羽毛的鸟
在第5章的“二模网络的理论”一节，我们简要得提及了同质性的概念——节点之间的链接的建立基于节点之间的相似度。但这个观念已经存在了几百年了（俗语说“羽毛相同的鸟总飞成一群”），在科学研究方面，拉扎斯菲尔德（Lazarsfeld）和墨顿（Merton）于1954年分析了这一下现象  ，他们区分了两种类型：身份同质性和价值同质性。&lt;/p&gt;

&lt;p&gt;身份同质性表示具有相同社会阶层、财富和地位的人（与随机的情况相比）更倾向于彼此相互联系。价值同质性表示倾向于与以相同方式思考或者喜欢相同的东西的人彼此相互联系，不管阶层和地位如何。&lt;/p&gt;

&lt;p&gt;美国文化当然更显著地受到价值同质性的影响，而在其它社会当中，个人的教育和阶层身份经常更清晰明确地影响他们所能接触到的信息或者文化人造品的类别。这在网络上更为明显，因为在互联网上“没有人知道你是一条狗”。一个人的网络身份虽然现在变得很普遍并接近于永久，但与线下的身份相比，仍然非常容易改变。&lt;/p&gt;

&lt;p&gt;地位同质性和价值同质性的一个区别正是在于“可塑性”（malleability） 。社会阶层和类别可被认为是永久的属性——社会流动通常是一个很缓慢的过程，因而无法通过社会网络分析把握。与之相反，价值同质性则以互联网的速度变化着。&lt;/p&gt;

&lt;p&gt;###同质性 VS. 好奇心
社会学家观察到另外一个有趣的现象——虽然同质性是一个很强的社会因素，但如果两个人不太像，但差异也没有达到使得两个人找不到谈话的话题时，另外一个因素将会发挥作用。这个因素是好奇心（获取信息的内在动机），结果使得形成链接的可能性呈现图 6-3中所示的双峰形状。对每个人来说，“好奇心山峰”的高度和位置是不同的，并且与我们的猎奇及规避猎奇的趋势有关（事实上，这可能是我们基因组成的一部分，尤其是我们大脑中的D1多巴胺受体的数量有关）——但它总以某种形状存在着。&lt;/p&gt;

&lt;p&gt;图 6-3 同质性与好奇心&lt;/p&gt;

&lt;p&gt;图字翻译：&lt;/p&gt;

&lt;p&gt;最主要的特征是“无聊的陷阱”。遇到一个和你在各个方面几乎一模一样无法提供新的信息或者刺激——于是建立链接的可能性迅速降低。人与人之间无聊的陷阱的位置和程度也不一样，并与我们的大脑对新奇性的需求和处理有关系。&lt;/p&gt;

&lt;p&gt;自我中心主义者的这个波动的极值是无法控制的，他们以没有能力处理新奇性和很难形成社会纽带并理解他人为特征。对威廉斯氏综合症患者来说，寻求新奇性和群集性走到了极端（缺乏抽象和空间逻辑能力）。&lt;/p&gt;

&lt;p&gt;你也可以把它看作一个随着时间的演变过程。想象一对刚刚遇到对方的男女。他们或许有一些相似的特质（都很年轻漂亮，如果没有其它地方相似），但总体上讲他们的同质化水平可能很低；相反，他们的好奇心都达到了顶峰。随着关系的进展，他们对彼此的了解不断加深，即使对于他们从来不会交流的事情。最终，男孩知道了他的女朋友背负着大笔的学生贷款，女孩了解到她的男朋友把脏袜子到处丢的坏习惯。这或许是位于好奇心和真的同质性之间的低谷。如果他们的关系走过了这个低谷，他们会变得能够接受了解对方所有的事情并且幸福得白头偕老。除了在之后的十几年里，他们没有对彼此说过一句话——如果他们相互之间没有什么新的消息为什么要说话呢？&lt;/p&gt;

&lt;p&gt;###跨界者&lt;/p&gt;

&lt;p&gt;我们每个人的基因组成和个性差异使得我们的社会网络也是不一样的，并且同质性到目前为止也不是普遍的。一些人喜欢做跨界者，他们和不同的群体存在联系，表现出来非常低的同质性。他们不仅是关键的信息通道，他们也可以利用作为中介和套利的机遇——这意味着在石器时代与不同部落建立贸易往来或者在现代在华尔街工作。我们已经在第4章的“禁止进入的三元组”和“结构洞”讨论过这个问题——但跨界行为也可以透过信息扩散的透镜来理解。&lt;/p&gt;

&lt;p&gt;###弱关系
在二十世纪七十年代，马克∙格兰诺维特（Mark Granovetter）开展了一项关于在南波斯顿某一个社群工作的蓝领工人的研究。他的大多数调查对象是爱尔兰移民，在建筑业或者其它技术工行业工作，并且花费大量的时间在酒吧里。工作，尤其是建筑业的工作，非常不稳定，在任何时间都有一部分人处于失业和找工作的状态中。这个研究项目的目标是研究工作信息如何在社会网络中流动。&lt;/p&gt;

&lt;p&gt;当地的酒吧是社交中心——每个人都定期地参加聚会并认识大多数其他去酒吧的人。所以最初的研究目的是分析酒吧里的谈话对于个人找工作能力的影响。&lt;/p&gt;

&lt;p&gt;但是结果非常令人吃惊——通过经常联系的酒吧里的朋友找到新工作仅占30%。大多数时候，工作信息来自于疏远的社会关系——远亲、朋友的姻亲等（也就是说，与他们存在弱的网络关系的人）。&lt;/p&gt;

&lt;p&gt;格兰诺维特推理强关系增加同质化程度——所以当一个人需要新的信息（比如，当找工作的时候），与处于中心的个体存在强关系的人缺乏任何新的信息。同时，通过弱关系联系的人们则完全不同（从信息连接的角度而言）。&lt;/p&gt;

&lt;p&gt;###邓巴数字和弱关系
在罗宾∙邓巴（Robin Dunbar）的论文中（现在已成为经典）  ，人类社会网络的平均规模（也就是平均的程度中心性）是150——并且从认知学角度来看，这个数字为前额皮质的大小或者我们推理其他人和关系的天赋才能所局限。&lt;/p&gt;

&lt;p&gt;但这不是那么简单的事情。我想用一个金字塔来展示邓巴数字的各段（见图 6-4）。在顶端，最强的关系是我们直系亲属和最好的朋友，我们每天与他们打交道，并认为他们是最亲密可信的人。邓巴发现这个亲密的群体的大小平均是7——它包括我们的配偶、父母、兄弟姐妹和子女。注意，这个数字和人类工作记忆的容量大小相同（7+/-3） ，所以我们可以推断我们的直接的和最亲密的社会联系是那些我们能够或必须存储在工作记忆中的。&lt;/p&gt;

&lt;p&gt;图 6-4 邓巴金字塔&lt;/p&gt;

&lt;p&gt;图字翻译：&lt;/p&gt;

&lt;p&gt;这个列表进一步分层为“扩展家庭”（extended family，这个群体包括朋友、表兄妹、姻亲等）：他们不是你每天都打交道的人，也不是你认为最亲密的人。再往下一层是“伙伴”，包括同事、一个更大的朋友和陌生人圈子、远亲。最下面一层包括其他所有的人，主要是你的弱关系。&lt;/p&gt;

&lt;p&gt;但是你的脸书朋友和推特朋友在哪里呢？多数情况下，他们位于金字塔的最底部。正如你从上面关于四种关系的描述中所看到的，当我们从金字塔上走下来，不同的社会关系所附带的情绪性和信息分享类信息不断降低，而人数不断增加。所以你的837个推特朋友所包含的情绪性注意力有多少呢？其实很少。&lt;/p&gt;

&lt;p&gt;对于一个服务行业的商业公司而言，社会化媒体的个体接触主要也是因为这个原因。当一个公司的代表与一个推特粉丝在个体层面上互动（例如，回应一个抱怨）的时候，他或她就在这种关系中投入了一些情绪性的能量。因为这种互动是公开的，它不仅维系着与一个现在的消费者之间的关系，还支撑着与其它的推特粉丝之间建立关系的（想象中的）可能性。&lt;/p&gt;

&lt;p&gt;因为每个人对于亲密的个体联系具有不同的偏好，这个金字塔对于每个人可能完全不同。我认识的一些人的最主要的社会联系来自于脸书和博客，他们的线上关系和“扩展家庭”开始融合。因为维持一个线上关系需要很少的情感投入，他们线上朋友可能有几千个却很少跟他们的直系亲属联系。近几年，网络流浪者开始变得与现实中睡在沙发上、一年周游国家数次的流浪者一样。&lt;/p&gt;

&lt;p&gt;##6.3 Python中的一个简单的动态模型
既然我们已经了解了相关的理论和例子，让我们开始尝试为社会网络中的信息扩散建立模型。我们将建立一个非常简单的多主体模型，在这个模型当中，社会网络中的主体之间相互影响并达成共识（如果这是可能的）。&lt;/p&gt;

&lt;p&gt;这个模型最初是由诺亚∙弗里德金（Noah Friedkin）于1998年提出来的  。这个模型遵守一个非常简单的前提：每个参加讨论的人对于问题都有自己的看法（或者他们自己的态度），并且每个人都在一定程度上接受来自其社会网络的朋友的影响。我们同时做出一个假设，模型中的主体所要交流的信息是一个介于0和1之间的数值。它可以是股票市场上升的可能性，或者一个主体使用一种非法药物的概率（这个模型曾用于研究信息在这两种情况下的扩散）。&lt;/p&gt;

&lt;p&gt;让我们开始建立我们的简单模型。我们并不会使用一个多主体建模的软件包，或者模拟包——其实我们也并不需要用它们来建立模型。&lt;/p&gt;

&lt;p&gt;让我们从为一个人定义一个Python的类开始：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(object):
    def __init__(self, id):
        #从一个单一的初始偏好开始
        self.id=id
        self.i = r.random()
        self.a = self.i
        #我们将初始意见和随后的信息对等
        self.alpha=0.8
    def __str__(self):
        return(str(self.id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个人有一个编号ID和三个重要的额数字：self.i是一个初始态度，self.a是一个演化出来的态度（它累积了这个人所有朋友的影响），最后self.alpha是我称之为“轻信程度因子”（也就是说，alpha越高，我越相信我的朋友的意见，并且越不相信自己最初的知识）。首先，我们假设每个人的轻信程度是完全相同的。&lt;/p&gt;

&lt;p&gt;现在，让我们创造一个以人为节点的网络。NetworkX允许我们使用任何对象作为一个网络节点，而我们将要利用这一特点:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;density=0.9
g=net.Graph()
## 创造一个以人为对象的网络
for i in range(10):
    p=Person(i)
    g.add_node(p)
##这是一个简单的随机网络，每对节点之间存在链接的概率相同
for x in g.nodes():
    for y in g.nodes():
        if r.random()&amp;lt;=density: g.add_edge(x,y)
## 画出这个生成的网络并按照节点的数字给节点赋予颜色
col=[n.a for n in g.nodes()]
pos=net.spring_layout(g)
net.draw_networkx(g,pos=pos, node_color=col)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我们初始化一个空的网络图，并在其中增加10个以人为类型的对象。然后，我们循环遍历每一个可能的两个节点之间的组合。使得概率等于密度的参数，我们将在两个节点之间添加一条链接。这种生成图的算法称之为厄多斯-任易（Erdos-Renyi）算法  ，是生成一个随机图的最简单的方法，并产生一个正态分布的度分布。&lt;/p&gt;

&lt;p&gt;厄多斯-任易（Erdos-Renyi）随机图已经成为许多图的算法和模型的一个基准，但我们现在知道，作为真实社会网络的代表它们非常不实际，因为多数社会网络具有一个长尾的度分布（也就是幂律）。但是，因为其它生成网络的方法更加复杂并超过了这个模型的范围，我们将在此使用这个简单的模型。这个网络看上去应与图 6-5相似。&lt;/p&gt;

&lt;p&gt;图 6-5 一个扩散模型的多主体的网络&lt;/p&gt;

&lt;p&gt;现在准备工作已经做完了，让我们开始创造模拟部分。在人这个类别中插入下面这个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def step(self):
    # 循环遍历所有的邻居并累加他们的偏好
    neighbors=g[self]
    # 所有的邻居节点的权重相同
    w=1/float((len(neighbors)+1))
    s=w*self.a
    for node in neighbors:
        s+=w*node.a

    # 更新我的意见为初始意见加上所有其它影响之和
    self.a=(1-self.alpha)*self.i + self.alpha*s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数基于他或她的朋友的态度加权总数和他或她的轻信程度因子（alpha）而更新一个个体的态度（a）。首先，我们将计算权重的大小。为了计算简便，每个人的意见所占的权重相等（第五行代码）。然后，我们计算一个个体自我意见，以及他或她的邻居中每个人的意见的加权之和（第6到第8行代码）。接着，我们更新现在的意见（第11行代码）:个体在时间t的意见等于客观知识乘以轻信因子，再加上他或她的所有朋友意见的加权之和。最后，让我们用一个循环的方式跑这段代码来看一下这个网络如何随着时间变化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##重复30个时间段
for i in range(30):
    ## 循环遍历所有的网络节点让它们走一步
    for node in g.nodes():
        node.step()

    ## 汇总演化而来的态度数值，输出到终端并画出结果。
    col=[n.a for n in g.nodes()]
    print col
    plot.plot(col)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跑这个模型30个时间段所得的结果看上去如图 6-6所示。随着时间变化，主体之间的意见越来越彼此相近，虽然它们从未达到共识。&lt;/p&gt;

&lt;p&gt;图 6-6 扩散模型运转一步&lt;/p&gt;

&lt;p&gt;让我们现在开始调整一下模型参数。如果所有的主体都非常轻信并接受他们的朋友所说的一切，那么结果会是怎样？让我们设置alpha = 1并看一下结果如何变化。图 6-7表明每个人很快达到共识——即使基于事实来看这个共识是完全错误的。&lt;/p&gt;

&lt;p&gt;图 6-7 扩散模型中的共识&lt;/p&gt;

&lt;p&gt;###处于中间的影响者
现在我们假设一些宣传主体（影响者、福音传教士）被嵌入到网络当中。每一个这样的节点都具有重要影响。在这个模型中，这些主体的意见是1，而其他所有主体的意见分布于0到1之间。
我们在模型中定义一个影响者为一种特殊类型的人：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Influencer(Person):
    def __init__(self,id):
        self.id=id
        self.i = r.random()
        self.a = 1 ## 它们的意见很强并且不可动摇

    def step(self):
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们添加一些影响者到这个网络中并将他们同其他主体相连：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;influencers=2
connections=4
##将影响者加入到网络之中并将他们与其它3个节点相连
for i in range(influencers):
    inf=Influencer(&amp;quot;Inf&amp;quot;+str(i))
    for x in range(connections):
        g.add_edge(r.choice(g.nodes()), inf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，像以前一样跑这个模型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 重复30个时间段
for i in range(30):
    ## 循环遍历网络中所有节点并让他们运转一步 
    for node in g.nodes():
        node.step()
    ##汇总演化而来的态度数值，输出到终端并画出结果。
    col=[n.a for n in g.nodes()]
    print col
    plot.plot(col)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图 6-8表明这两个影响者具有一个很强的效果——但是，初始位置并不允许主体完全地朝着极值迁移。影响者的数量越多，模型朝向一个极值的共识演化的可能性越高。&lt;/p&gt;

&lt;p&gt;图 6-8 添加两个影响者进入网络中以加速网络朝向极值的演化&lt;/p&gt;

&lt;p&gt;这个模型非常简单，没有考虑许多其它影响信息扩散的因素。其中没有同质化的影响，也没有临界质量的作用，并且模型的演化是线性的。但是，这是一个开始，我们要进一步优化这个模型。&lt;/p&gt;

&lt;p&gt;###练习
我在这里所展现的这个模型的实现方式过于简单。读者可以尝试下面这些主意：&lt;/p&gt;

&lt;p&gt;• 使得轻信程度因子异质化而不是所有的主体的轻信程度因子相同。&lt;/p&gt;

&lt;p&gt;• 试验使用多个参数调节的无标度网络而不是使用简单的随机网路。&lt;/p&gt;

&lt;p&gt;• 对于朋友的意见应用信任权重（也就是说，不是给所有的意见的相同权重）而不是基于主体之间的链接的强度。&lt;/p&gt;

&lt;p&gt;• 使用多个维度的态度进行计算——一个真实的人对于不同的事情有多种态度，模型中的主体也是这样。&lt;/p&gt;

&lt;p&gt;##6.4网络和信息的共同演化
现在我们将要优化这个模型中的影响因素，以便允许不同的网络类型、个体的态度和网络中的信息内容。首先，我们将把step函数从之前的模型中去掉，与之相反，引入一个和单一主体交换信息的互动函数，而不是和所有的邻居交换信息。轻信程度因子的作用在这里同样适用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 随机的挑选一个节点交换信息，
## 而不是和所有的节点交换信息。
## 这将创造一条边并根据他们之间的相似性赋予权重。
def interact(self):
    partner=r.choice(g.nodes())
    s=0.5*(self.a + partner.a)
    # # 更新我的意见为初始意见加上所有其它影响之和
    self.a=(1-self.alpha)*self.i + self.alpha*s
    g.add_edge(self,partner,weight=(1-self.a-partner.a))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到现在为止，这是一个随机的选择。在信息的交换和接收之后，我们将在两个节点之间创造一条链接。这条边将被按照相似度赋予权重——节点之间的相似程度越高，他们之间建立的链接的强度越高。&lt;/p&gt;

&lt;p&gt;但是，我们也知道在一段时间过去之后，链接会逐渐减少，一个最简单的方法是用一个为常数的衰变率（decay rate）来描述：&lt;/p&gt;

&lt;p&gt;v(t+1)=v(t)*(1-decay_rate)&lt;/p&gt;

&lt;p&gt;衰变率在现实网络中是非常低的，但是在线上社会网络中会明显得要高（因为在脸书上取消朋友关系或者只是忽视他们的信息与跟现实世界中的朋友吵架相比，要简单很多）。但是，这个模型非常抽象，所以我们将选择一个简单的数字。我们设置网络的衰变率在每个时间段为1%。&lt;/p&gt;

&lt;p&gt;tips:
一个模拟中的时间段是完全随意的。但是，人们也可以将它（以及衰变率）与作为交往频率的函数的链接的强度的概念相联系，见第2章“什么是图”一节的描述。&lt;/p&gt;

&lt;p&gt;所以，以之前的方式，让我们初始化这个网络，并运行这个模拟。图 6-9表明一个与其他节点联系紧密的节点，如何在他/她周围分布着一小群意见相似的粉丝，而那些与其他节点联系并不紧密的节点保持着与众不同的意见。这样，带有完全不同意见的节点可以和平共处并且共识会涌现（如图 6-10）。&lt;/p&gt;

&lt;p&gt;图 6-9 这个网络表明意见相似的节点之间联系紧密而意见不同的节点分布于边缘上&lt;/p&gt;

&lt;p&gt;图 6-10 网络和态度的改变允许冲突的态度和多种共识并存&lt;/p&gt;

&lt;p&gt;但是，这也依赖于传播参与者的随机选择这个概念——我们知道这是不正确的（见本章“信息如何影响网络（反之亦然）？”一节）。所以，现在让我们引入同质性的概念。这样做，每个人都维持着自己与他/她所知道的一系列的人的关系，以及自己在多大程度上与他们相似。在这个例子当中，我们已将同质化程度数值存储在图的链接属性中，通过下面这行代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g.add_edge(self,partner,weight=(1-self.a-partner.a))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在我们开始利用这个信息选取互动对象之前，我们来讨论一点关于选择的事情。正如我们在 本章前面“信息如何影响网络（反之亦然）？”一节所讨论的一样，我们以更高的概率选择与我们相似的人——但是兴趣中的第二个峰值使我们与和我们非常不同的人交谈。一些传播行为也可能是随机的。为了允许我们按照正比于和其他人的相似度（或不相似度）水平的概率挑选互动对象，我们应用一个叫做“轮盘赌选择”的程序。&lt;/p&gt;

&lt;p&gt;图 6-11 选择网络伙伴的有权重的轮盘赌&lt;/p&gt;

&lt;p&gt;想象一个轮盘赌的轮子的各个扇区之间的权重是不同的（图 6-11）。这样，将赌注押在一些扇区上赢得概率更高，轮盘的旋转是公平的（也就是均匀分布的）。我们通过按照相似度水平构建一个传播伙伴的列表（如果需要，多次重复他们的名字）的方法应用轮盘赌方法。这样，一个从列表中进行的一致的随机选择，将返回一个权重分配合理的轮盘赌选择：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def _roulette_choice(self,names,values, inverse=False):
    &amp;quot;&amp;quot;&amp;quot;
    轮盘赌方法基于一组数字得到不同权重的选择
    名字和数值应该是等长的列表
    数值的范围在0到1之间
    如果 inverse=False, 数值较高的名字具有更高的选择概率
    如果inverse=True，数值更低的名字具有更高的选择概率
    &amp;quot;&amp;quot;&amp;quot;
    wheel=names
    for i in range(len(names)):
        if not inverse:
            wheel.extend([names[i] for x in range(1+int(values[i]*10))])
        else:
            wheel.extend([names[i] for x in range(1+int((1-values[i])*10))])
    return(r.choice(wheel))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们需要优化interact（）方法一允许我们使用轮盘赌方法。我们再一次掷骰子并决定是否传播伙伴是相似的（以一个0.6的概率）或不相似的（以一个0.3的概率）或完全随机的（以一个0.1的概率）。如果一个人不和任何人说话，他/她将随机地挑选并建立一些网络链接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def interact(self):
    &amp;quot;&amp;quot;&amp;quot;
    随机的挑选一个节点交换信息，
          而不是和所有的节点交换信息。
    这将创造一条边并根据他们之间的相似性赋予权重。
    阶段 II –使用轮盘赌选择而非随机选择
    &amp;quot;&amp;quot;&amp;quot;
    neighbors=g[self].keys()
    values=[v[&#39;weight&#39;] for v in g[self].values()]
    ##掷骰子已决定互动的概率 
    ## 相似 (0.6), 不相似(0.3)或随机 (0.1)
    roll=r.random()
    if r &amp;lt;= 0.1 or len(neighbors)==0:
        partner=r.choice(g.nodes())
    elif r&amp;lt;=0.4:
        partner=self._roulette_choice(neighbors,values,inverse=True)
    else:
        partner=self._roulette_choice(neighbors,values,inverse=False)
    w=0.5
    s=self.a*w + partner.a*w
    #  更新我的意见为初始意见加上所有其它影响之和
    self.a=(1-self.alpha)*self.i + self.alpha*s
    g.add_edge(self,partner,weight=(1-self.a-partner.a))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们也优化这个模型以便生成更多的一些图。第一个是“共识图”——展示的是网络中每个人的平均意见，以及最大和最小值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def consensus(g):
    &amp;quot;&amp;quot;&amp;quot;
    计算图中的作为共识的意见
    &amp;quot;&amp;quot;&amp;quot;
    aa=[n.a for n in g.nodes()]
    return min(aa),max(aa),sum(aa)/len(aa)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将模型的每一次迭代生成的网络共识的数值添加到一个列表里，并在后面绘制出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cons=[]
for i in range(runtime):
    for node in g.nodes():
        node.interact()
....
....模拟代码在这里....
....
cons.append(consensus(g))
....
.... 模型的最后一次运转之后....
....
plot.figure(i+1)
plot.plot(cons)
同时，让我们通过绘制直方图的方式来看一下边的数值。
plot.figure(i+2)
plot.hist([e[&#39;weight&#39;] for f,t,e in g.edges(data=True)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tips:
完整的模型代码可以从Github下载（&lt;a href=&#34;https://github.com/maksim2042/SNABook/chapter6）&#34; target=&#34;_blank&#34;&gt;https://github.com/maksim2042/SNABook/chapter6）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;让我们现在重新载入并运转这个模型。结果如图 6-12和6-13所示。&lt;/p&gt;

&lt;p&gt;图 6-12 最终的网络中，节点的意见可以非常不一样&lt;/p&gt;

&lt;p&gt;图 6-13 网络收敛到一个在可接受范围内的意见，但允许内部存在一些多样性&lt;/p&gt;

&lt;p&gt;我们的第一个观察是网络迅速地到达了稳定状态——但这个稳定状态并非形成共识，而是排除了最高和最低极端意见的一种分布广泛的可接受的意见，这种状态适于形成一种让人感到舒适的平均意见。在缺少意见领袖的条件下，平均意见的选取是非常随机的——但是我们可以非常肯定的是，如果我们的随机数生成器是公平的，取得的结果是远离极值的。&lt;/p&gt;

&lt;p&gt;网络并未变成群集内部同质化——相反，如果节点的意见在可接受范围内，那么它们可以共存于一个稳定的动态均衡中。这是如何实现的呢？&lt;/p&gt;

&lt;p&gt;我们在本章中讨论了这个机制——它是弱关系。如果你以直方图的形式绘制出这个网络的链接的强度（图 6-14），你会发现强关系非常少见（特别弱的关系也很少见）。相反，链接的强度似乎分布于一个0.3的均值左右，这是一个很好的、稳定的弱关系。&lt;/p&gt;

&lt;p&gt;图 6-14 多数链接是弱关系或者中等弱关系，正如邓巴金字塔所展示的。&lt;/p&gt;

&lt;p&gt;这进一步加强了链接强度的邓巴金字塔——强关系很少见并且需要完全的共识（这也是很少见的），相反弱关系很容易建立并维持。&lt;/p&gt;

&lt;p&gt;##练习
•   加入影响者。他们如何改变演化动态？如果一些影响者互相冲突（具有截然相反地意见），网络会分化吗？&lt;/p&gt;

&lt;p&gt;•   在模型中加入大的冲击。例如，一个主体可以在一个随机的时刻将自己的意见改变为极值。他/她的朋友们是否回来劝阻他/她？&lt;/p&gt;

&lt;p&gt;•   加入不同传播能力的主体。例如，广播者可以一次同所有的人讲话。&lt;/p&gt;

&lt;p&gt;•   在这个模型的基础上构建一个选举模型。一些候选人为了获得全体的注意力而竞争。他们应采用什么样的竞选策略以影响结果？&lt;/p&gt;

&lt;p&gt;###为什么为网络建立模型
在本节里，我们已经表明使用寥寥数行代码，我们能够概述关于网络动态和变化的理论，并尝试去通过模拟的方法检验它们。经常地，在一个需要和很多实证数据打交道的环境里，形成一个关于驱动网络变化以及变化方向的简洁的理论变得非常困难。模拟模型帮助我们发展出更简洁的理论，并允许我们很快地检验多种不同的观点 。&lt;/p&gt;

&lt;p&gt;这个模型可以作为建立其它信息扩散模型的实验基地。例如，想象一个网络当中的一些节点出现然后又消失以传递一些独特的信息。或者一个在一段时间内可以不受干扰地演化的网络，之后注入一个重要的信息（例如，“传教士和野人”问题 ）。或者，想象着是一个模拟毒品贩运网络的模型，作为一个警察局的网络专家，你需要破坏网络中的信息流动。类似的可能性是无穷无尽的。&lt;/p&gt;

&lt;p&gt;可计算社会科学（Computational Social Science ，简称为CCS）的整个领域已经从社会网络分析、人工生命、人工智能以及其它的一些领域的交汇中开始升起。这或许将成为我们下一本书的主题。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
