<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on </title>
    <link>https://chengjun.github.io/en/categories/network/index.xml</link>
    <description>Recent content in Network on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Cheng-Jun Wang</copyright>
    <atom:link href="/en/categories/network/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Generating networks with igraph</title>
      <link>https://chengjun.github.io/en/post/en/2013-08-12-generating-networks-with-igraph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/en/post/en/2013-08-12-generating-networks-with-igraph/</guid>
      <description>

&lt;p&gt;We know that the most simple network is the regular network, such as the ring network. If all the edges in a network are generated randomly, we can get a random graph or Erdos-Renyi network (ER network).&lt;/p&gt;

&lt;h2 id=&#34;erdős-rényi-random-graph-model&#34;&gt;Erdős–Rényi Random Graph model&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The Erdős–Rényi model, named for Paul Erdős and Alfréd Rényi, is used for generating random graphs in which edges are set between nodes with equal probabilities.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is a continuous shift between randomness and regularity. What are the networks between random network and regular networks?&lt;/p&gt;

&lt;h2 id=&#34;watts-strogatz-small-world-model&#34;&gt;Watts-Strogatz Small World model&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The Watts and Strogatz model is a random graph generation model that produces graphs with small-world properties.
An initial lattice structure is used to generate a Watts-Strogatz model. Each node in the network is initially linked to its k closest neighbors. Another parameter is specified as the rewiring probability. Each edge has a probability p that it will be rewired to the graph as a random edge.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;barabási-albert-ba-preferential-attachment-model&#34;&gt;Barabási–Albert (BA) Preferential Attachment model&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The Barabási–Albert model is a random network model used to demonstrate a preferential attachment or a &amp;ldquo;rich-get-richer&amp;rdquo; effect. In this model, an edge is most likely to attach to nodes with higher degrees. The network begins with an initial network of m nodes. m ≥ 2 and the degree of each node in the initial network should be at least 1, otherwise it will always remain disconnected from the rest of the network.&lt;/p&gt;

&lt;p&gt;In the BA model, new nodes are added to the network one at a time. Each new node is connected to m existing nodes with a probability that is proportional to the number of links that the existing nodes already have.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can use igraph to play the network games, and explore the properties of generated networks.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;igraph is an open source C library for the analysis of large-scale complex networks, with interfaces to R, Python and Ruby.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is the R script for generating and visualizing networks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(igraph)
g1 &amp;lt;- graph.ring(500)
g2 &amp;lt;- erdos.renyi.game(500, 0.0035)
g3 &amp;lt;- rewire.edges( g1, prob = 0.5 )
g4 &amp;lt;- barabasi.game(500)
# 保存图片格式
png(&amp;quot;d:/network_game.png&amp;quot;,
    width=5, height=5,
    units=&amp;quot;in&amp;quot;, res=700)
# 绘制图片
par(mfrow=c(2,2))
plot(g1, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = &amp;quot;Ring Network&amp;quot;)
plot(g2, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = &amp;quot;Random Network&amp;quot;)
plot(g3, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = &amp;quot;Small World Network&amp;quot;)
plot(g4, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = &amp;quot;Scale-free Network&amp;quot;)
# 结束保存图片
dev.off()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2875/9490993155_0787ab3832_c.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Of courese, there are other network games in the library of igraph, such as the game of forest fire.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g5 &amp;lt;- forest.fire.game(200, fw.prob=0.37, bw.factor=0.32/0.37)
plot(g5, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Network_science#Network_models&#34; target=&#34;_blank&#34;&gt;http://en.wikipedia.org/wiki/Network_science#Network_models&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simulating network diffusion with R</title>
      <link>https://chengjun.github.io/en/post/en/2014-03-09-simulate-network-diffusion-with-R/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chengjun.github.io/en/post/en/2014-03-09-simulate-network-diffusion-with-R/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Different from the traditional diffusion research, network diffusion research focuses on how network structure exerts its impact on the diffusion process. In this post, I present how to simulate the most simple network diffusion with R.&lt;/p&gt;

&lt;p&gt;As the first step, the algorithm is quite simple:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Generate a network g: g(V, E).&lt;/li&gt;
&lt;li&gt;Randomly select one or n nodes as seeds.&lt;/li&gt;
&lt;li&gt;Each infected node influences its neighbors with probability p (transmission rate, $$\beta$$).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;si-model&#34;&gt;SI model&lt;/h2&gt;

&lt;p&gt;Actually, this is the most basic epidemic model (SI model) which has only two states: Susceptible (S) and Infected (I). However, we will extend it to networks.&lt;/p&gt;

&lt;p&gt;SI model describes the status of individuals switching from susceptible to infected. In this model, every individual will be infected eventually. Considering a close population without birth, death, and mobility, and assuming that each agent is homogeneous mixing,  SI model implies that each individual has the same probability to transfer the something (e.g., disease, innovation or information) to its neighbors (T. G. Lewis, 2011).&lt;/p&gt;

&lt;p&gt;Given the transmission rate $$\beta$$, SI model can be described as:&lt;/p&gt;

&lt;p&gt;$$\frac{dS}{dt}=-\beta SI$$&lt;/p&gt;

&lt;p&gt;$$\frac{dI}{dt}=\beta SI$$&lt;/p&gt;

&lt;p&gt;Note that I + S = 1, the equation $$\frac{dI}{dt}=\beta SI$$ can be simplified as:&lt;/p&gt;

&lt;p&gt;$$\frac{dI}{dt}=\beta I(1-I)$$&lt;/p&gt;

&lt;p&gt;Solve this equation, we can get a logistic growth function featured by its s-shaped curve. The logistic curve increases fast after it crosses the critical point, and grows much slower in the late stage. It can be used to fit the curve of diffusion of innovations.&lt;/p&gt;

&lt;p&gt;Note that the SI model is quite naive. In the real case of epidemic spreading, we have to consider how the status of the infected change: the infected can recover and become susceptible again (SIS model), or the infected can recover and get immune (SIR, $$\gamma$$ denotes the removal or recovery rate).&lt;/p&gt;

&lt;p&gt;In this post, I intend to bring the network back into the simulation of SI model using R and the package igraph.&lt;/p&gt;

&lt;h2 id=&#34;generate-the-network&#34;&gt;Generate the network&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;require(igraph)
# generate a social graph
size = 50

# regular network
g = graph.tree(size, children = 2); plot(g)
g = graph.star(size); plot(g)
g = graph.full(size); plot(g)
g = graph.ring(size); plot(g)
g = connect.neighborhood(graph.ring(size), 2); plot(g) # 最近邻耦合网络

# random network
g = erdos.renyi.game(size, 0.1)

# small-world network
g = rewire.edges(erdos.renyi.game(size, 0.1), prob = 0.8 )
# scale-free network
g = barabasi.game(size) ; plot(g)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;initiate-the-diffusers&#34;&gt;Initiate the diffusers&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;seeds_num = 1
set.seed(2014); diffusers = sample(V(g),seeds_num) ; diffusers
infected =list()
infected[[1]]= diffusers

# for example, set percolation probability
p = 0.128
coins = c(rep(1, p*1000), rep(0,(1-p)*1000))
n = length(coins)
sample(coins, 1, replace=TRUE, prob=rep(1/n, n))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-the-diffusers&#34;&gt;Update the diffusers&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# function for updating the diffusers
update_diffusers = function(diffusers){
  nearest_neighbors = neighborhood(g, 1, diffusers)
  nearest_neighbors = data.frame(table(unlist(nearest_neighbors)))
  nearest_neighbors = subset(nearest_neighbors, !(nearest_neighbors[,1]%in%diffusers))
  # toss the coins
  toss = function(freq) {
    tossing = NULL
    for (i in 1:freq ) tossing[i] = sample(coins, 1, replace=TRUE, prob=rep(1/n, times=n))
    tossing = sum(tossing)
    return (tossing)
  }
  keep = unlist(lapply(nearest_neighbors[,2], toss))
  new_infected = as.numeric(as.character(nearest_neighbors[,1][keep &amp;gt;= 1]))
  diffusers = unique(c(diffusers, new_infected))
  return(diffusers)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;start-the-contagion&#34;&gt;Start the contagion!&lt;/h2&gt;

&lt;p&gt;R you Ready? Now we can start the contagion!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i = 1
while(length(infected[[i]]) &amp;lt; size){
  infected[[i+1]] = sort(update_diffusers(infected[[i]]))
  cat(length(infected[[i+1]]), &amp;quot;\n&amp;quot;)
  i = i + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at the diffusion curve first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# &amp;quot;growth_curve&amp;quot;
num_cum = unlist(lapply(1:i, function(x) length(infected［x］) ))
p_cum = num_cum/max(num_cum)
time = 1:i

png(file = &amp;quot;./temporal_growth_curve.png&amp;quot;,
    width=5, height=5,
    units=&amp;quot;in&amp;quot;, res=300)
plot(p_cum~time, type = &amp;quot;b&amp;quot;)
dev.off()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7299/12845959103_e19cd9cd99_n.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To visualize the diffusion process, we label the infected nodes with the red color.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E(g)$color = &amp;quot;blueviolet&amp;quot;
V(g)$color = &amp;quot;white&amp;quot;
set.seed(2014); layout.old = layout.fruchterman.reingold(g)
V(g)$color[V(g)%in%diffusers] = &amp;quot;red&amp;quot;
plot(g, layout =layout.old)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I make the animated gif using the package animation developed by Yihui Xie.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(animation)

saveGIF({
  ani.options(interval = 0.5, convert = shQuote(&amp;quot;C:/Program Files/ImageMagick-6.8.8-Q16/convert.exe&amp;quot;))
  # start the plot
  m = 1
  while(m &amp;lt;= length(infected)){
    V(g)$color = &amp;quot;white&amp;quot;
    V(g)$color[V(g)%in%infected[[m]]] = &amp;quot;red&amp;quot;
    plot(g, layout =layout.old)
    m = m + 1}
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3806/12826172695_368a6f50a2_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2848/12826237753_d8c97b1019_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3729/12826584654_c84452f397_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2851/12826173505_34649f488d_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7391/12826173255_574e471023_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3675/12826584484_7c6f35380c_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7432/12826173045_ef3548ec04_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Similar to Netlogo (a software used for agent-based modeling), we can monitor the dynamic diffusion process with multiple plots.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saveGIF({
  ani.options(interval = 0.5, convert = shQuote(&amp;quot;C:/Program Files/ImageMagick-6.8.8-Q16/convert.exe&amp;quot;))
  # start the plot
  m = 1
  while(m &amp;lt;= length(infected)){
    # start the plot
    layout(matrix(c(1, 2, 1, 3), 2,2, byrow = TRUE), widths=c(3,1), heights=c(1, 1))
    V(g)$color &amp;lt;- &amp;quot;white&amp;quot;
    V(g)$color[V(g)%in%infected[[m]]] = &amp;quot;red&amp;quot;
    num_cum = unlist(lapply(1:m, function(x) length(infected[[x]]) ))
    p_cum = num_cum/size
    p = diff(c(0, p_cum))
    time = 1:m
    plot(g, layout =layout.old, edge.arrow.size=0.2)
    title(paste(&amp;quot;Scale-free Network \n Day&amp;quot;, m))
    plot(p_cum~time, type = &amp;quot;b&amp;quot;, ylab = &amp;quot;CDF&amp;quot;, xlab = &amp;quot;Time&amp;quot;,
         xlim = c(0,i), ylim =c(0,1))
    plot(p~time, type = &amp;quot;h&amp;quot;, ylab = &amp;quot;PDF&amp;quot;, xlab = &amp;quot;Time&amp;quot;,
         xlim = c(0,i), ylim =c(0,1), frame.plot = FALSE)
    m = m + 1}
}, ani.width = 800, ani.height = 500)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3672/12848749413_7f9da8b8c7_o.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Based on this post, I made slides using Rpres in Rstudio, you can view it  following this &lt;a href=&#34;http://chengjun.github.io/network-diffusion&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;http://chengjun.github.io/network-diffusion/&#34; width = &#34;600&#34; height = &#34;400&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
